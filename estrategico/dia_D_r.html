<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dia "D"</title>
    <link href="https://unpkg.com/leaflet/dist/leaflet.css" rel="stylesheet" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        font-family: "Segoe UI", Arial, sans-serif;
        background: #f4f4f4;
      }
      :root {
        --sidebar-w: 320px;
      }
      #panel-lateral {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: var(--sidebar-w);
        height: 100%;
        background: linear-gradient(180deg, #8ea3ad 0%, #dfe6e9 100%);
        color: #2c3e50;
        border-right: 1px solid #b2bec3;
        display: flex;
        flex-direction: column;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
        box-sizing: border-box;
        align-items: stretch;
        z-index: 2000;
      }
      #panel-header {
        background: #b2bec3;
        color: #2c3e50;
        padding: 12px 15px;
        display: flex;
        align-items: center;
        font-size: 18px;
        font-weight: bold;
      }
      #panel-header img {
        height: 32px;
        margin-right: 10px;
      }
      #map {
        position: absolute;
        top: 0;
        left: var(--sidebar-w);
        width: calc(100% - var(--sidebar-w));
        height: 100%;
        background: #e5e7eb;
      }

      /* Mapa oculto hasta que el usuario lo solicite */
      .map-hidden {
        display: none;
      }

      #sec-search {
        position: relative;
      } /* contenedor del buscador */
      #sec-suggest {
        z-index: 3000;
      }
      #sec-suggest {
        position: absolute;
        left: 12px;
        right: 12px;
        top: 46px; /* ajusta seg√∫n tu input */
        max-height: 220px;
        overflow: auto;
      }
      /* la lista queda clickeable */

      /* Etiqueta de la SECCI√ìN seleccionada (rosa tenue) */
      .sec-label {
        background: rgba(255, 235, 238, 0.96); /* #ffebee */
        border: 1px solid #e91e63;
        color: #880e4f;
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 12px;
        font-weight: 700;
        pointer-events: none;
        white-space: nowrap;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      }

      /* Etiquetas de SECCIONES ADYACENTES (azul/gris tenue) */
      .sec-label-adj {
        background: rgba(227, 242, 253, 0.94); /* #e3f2fd */
        border: 1px solid #64b5f6;
        color: #0d47a1;
        padding: 1px 5px;
        border-radius: 8px;
        font-size: 11px;
        font-weight: 600;
        pointer-events: none;
        white-space: nowrap;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.12);
      }

      /* Panel flotante secci√≥n */
      #sec-info {
        position: absolute;
        left: 12px;
        bottom: 380px;
        width: 300px;
        max-width: 38vw;
        min-width: 260px;
        background: #ffffff;
        border: 1px solid #cfd8dc;
        border-radius: 10px;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.15);
        resize: both;
        overflow: auto;
        z-index: 4000;
        display: none;
        pointer-events: auto;
      }
      #sec-info .hdr {
        cursor: move;
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: linear-gradient(180deg, #eceff1, #e3f2fd);
        padding: 8px 12px;
        border-bottom: 1px solid #cfd8dc;
        font-weight: 700;
        color: #263238;
      }

      #sec-info .hdr .btn-close {
        cursor: pointer;
        border: none;
        outline: none;
        background: #ffcdd2; /* rosa tenue */
        color: #880e4f;
        width: 24px;
        height: 24px;
        line-height: 24px;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 800;
      }
      #sec-info .hdr .btn-close:hover {
        background: #ef9a9a;
      }
      #sec-info .body {
        padding: 10px 12px;
        color: #37474f;
      }
      #sec-info .row {
        display: flex;
        justify-content: space-between;
        margin: 6px 0;
      }
      #sec-info .k {
        color: #607d8b;
      }
      #sec-info .v {
        font-weight: 600;
      }

      .diaD-menu {
      position: absolute;
      background: white;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      padding: 6px 0;
      width: 180px;
      z-index: 4500;
      
    }

    .diaD-menu div {
      padding: 8px 14px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .diaD-menu div:hover {
      background: #eef2ff;
    }

    .diaD-menu.hidden {
      display: none;
    }


      /* ===== Panel D√≠a D (secci√≥n ‚Üí casillas) ===== */
      #diaD-panel {
        position: absolute;
        top: 70px;          /* aj√∫stalo si quieres m√°s arriba / abajo */
        right: 20px;
        width: 460px;
        height: 800px;      /* üëà m√°s alto que antes */
        max-height: 80vh;   /* no pasa del 80% de la pantalla */
        background: #ffffff;
        border-radius: 10px;
        box-shadow: 0 18px 45px rgba(15, 23, 42, 0.18);
        display: none;
        overflow: hidden;   /* el scroll lo lleva el interior */
        z-index: 4500;
      }

      #diaD-filter-titlebar {
        background: #2c3e50;
        color: #fff;
        padding: 8px 12px;
        cursor: move;   /* üëà indica que se puede arrastrar */
        font-weight: bold;
        border-radius: 12px 12px 0 0; /* esquinas superiores redondeadas */
      }
      .panel-content {
        padding: 16px;
      }


      #diaD-resize-handle {
        position: absolute;
        width: 14px;
        height: 14px;
        right: 4px;
        bottom: 4px;
        cursor: se-resize;
        background: linear-gradient(135deg, #cbd5f5 0%, #64748b 100%);
        border-radius: 4px;
      }

      #diaD-panel .d1-body {
        padding: 8px 12px 10px;
        height: calc(100% - 50px);  /* ajusta resto del panel */
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      #diaD-panel .d1-table-wrap {
        margin-top: 6px;
        flex: 1 1 auto;
        max-height: none;          /* dejamos que lo limite .d1-body */
        overflow-y: auto;
        overflow-x: auto;
      }

      #diaD-panel .hdr {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 12px;
        background: linear-gradient(180deg, #f8fafc, #eef2f7);
        border-bottom: 1px solid #e5e7eb;
        cursor: move; /* para indicar que se puede arrastrar */
      }

      #diaD-panel .ttl {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      #diaD-panel .ttl-main {
        font-weight: 700;
        color: #111827;
      }

      #diaD-panel .ttl-sub {
        font-size: 11px;
        color: #64748b;
      }

      #diaD-panel .btn-close {
        border: none;
        background: #ffe7ea;
        color: #7f1d1d;
        width: 26px;
        height: 26px;
        border-radius: 8px;
        font-size: 16px;
        cursor: pointer;
      }
      #diaD-panel .btn-close:hover {
        background: #fecaca;
      }

      #diaD-panel .body {
        padding: 8px 12px 10px;
        max-height: calc(80vh - 48px);
        overflow: auto;
      }

      /* KPIs */
      #diaD-panel .kpis {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 10px;
      }
      #diaD-panel .kpi {
        flex: 1 1 120px;
        border: 1px solid #e5e7eb;
        border-radius: 10px;
        padding: 6px 8px;
        background: #fbfdff;
      }
      #diaD-panel .kpi .t {
        font-size: 11px;
        color: #64748b;
      }
      #diaD-panel .kpi .v {
        font-size: 18px;
        font-weight: 700;
        color: #111827;
      }

      /* Barra de tareas D√≠a D */
      #diaD-toolbar {
        position: absolute;
        top: 10px;
        right: 20px;
        z-index: 4600;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
      }

      #diaD-toolbar #btn-diaD-status {
        padding: 6px 10px;
        font-size: 12px;
        border-radius: 999px;
        border: 1px solid #cbd5f5;
        background: #ffffff;
        box-shadow: 0 4px 10px rgba(15,23,42,0.15);
        cursor: pointer;
      }

      #diaD-toolbar #btn-diaD-status:hover {
        background: #eef2ff;
      }

      .diaD-toolbar-menu {
        margin-top: 4px;
        background: #ffffff;
        border-radius: 8px;
        box-shadow: 0 10px 24px rgba(15,23,42,0.18);
        padding: 4px 0;
        min-width: 190px;
      }

      .diaD-toolbar-menu div {
        padding: 6px 10px;
        font-size: 13px;
        cursor: pointer;
      }

      .diaD-toolbar-menu div:hover {
        background: #eef2ff;
      }

      .hidden {
        display: none;
      }

      /* Panel global de estatus */
      .diaD-status-panel {
        position: absolute;
        top: 70px;
        right: 20px;
        width: 520px;
        max-height: 70vh;
        background: #ffffff;
        border-radius: 10px;
        box-shadow: 0 18px 45px rgba(15,23,42,0.22);
        overflow: hidden;
        z-index: 4550;
      }

      .diaD-status-panel .body {
        padding: 8px 12px 10px;
        max-height: calc(70vh - 48px);
        overflow: hidden;
      }

      .d2-table-wrap {
        margin-top: 6px;
        max-height: calc(70vh - 80px);
        overflow-y: auto;
      }

      .dd-badge-acta{
        display:inline-block;
        padding:3px 8px;
        border-radius:999px;
        font-size:12px;
        font-weight:600;
        background:#eef2ff;
        color:#3730a3;
      }


      #diaD-status-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }

      #diaD-status-table th,
      #diaD-status-table td {
        border-bottom: 1px solid #f1f5f9;
        padding: 5px 6px;
        text-align: left;
        vertical-align: top;
      }

      #diaD-status-table tbody tr:hover {
        background: #f1f5f9;
        cursor: pointer;
      }


      /* Tabla de casillas */
      #diaD-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
        table-layout: fixed;
      }
      #diaD-table th,
      #diaD-table td {
        border-bottom: 1px solid #f1f5f9;
        padding: 6px 6px;
        text-align: left;
        vertical-align: top;
        word-break: break-word;
      }
      /* Distribuci√≥n: Casilla compacta, Domicilio amplio, resto ajustado */
      #diaD-table th:nth-child(1),
      #diaD-table td:nth-child(1) {
        width: 70px;
      }
      #diaD-table th:nth-child(2),
      #diaD-table td:nth-child(2) {
        width: 42%;
        min-width: 220px;
      }
      #diaD-table th:nth-child(3),
      #diaD-table td:nth-child(3) {
        width: 18%;
      }
      #diaD-table th:nth-child(4),
      #diaD-table td:nth-child(4) {
        width: 14%;
      }
      #diaD-table th:nth-child(5),
      #diaD-table td:nth-child(5) {
        width: 16%;
      }
      #diaD-table th:nth-child(6),
      #diaD-table td:nth-child(6) {
        width: 100px;
      }
      #diaD-table th {
        position: sticky;
        top: 0;
        background: #ffffff;
        z-index: 1;
      }

      #diaD-table tbody tr.d1-row-selected {
        background: #fef3c7;
      }

      #diaD-table tbody tr.d1-row-selected td {
        border-bottom-color: #fbbf24;
      }

      /* Chips de estatus */
      .d1-chip {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 2px 6px;
        border-radius: 999px;
        font-size: 11px;
        font-weight: 600;
        border: 1px solid transparent;
      }

            /* Columna de actas (chips A, DL, DF, G, S, P) */
      #diaD-table td.d1-actas-cell {
        white-space: nowrap;
        max-width: 140px;
      }

      .d1-chip-acta {
        margin-right: 2px;
      }

      .d1-chip-acta-a{
        background: #eff6ff;
        color: #1d4ed8;
        border-color: #bfdbfe;
      }
      .d1-chip-acta-dl{
        background: #ecfdf5;
        color: #047857;
        border-color: #bbf7d0;
      }
      .d1-chip-acta-df{
        background: #fef3c7;
        color: #92400e;
        border-color: #fde68a;
      }
      .d1-chip-acta-g{
        background: #fef2f2;
        color: #b91c1c;
        border-color: #fecaca;
      }
      .d1-chip-acta-s{
        background: #f5f3ff;
        color: #6d28d9;
        border-color: #ddd6fe;
      }
      .d1-chip-acta-p{
        background: #fdf2f8;
        color: #9d174d;
        border-color: #fbcfe8;
      }


      .d1-chip.ok {
        background: #dcfce7;
        color: #166534;
        border-color: #bbf7d0;
      }
      .d1-chip.mid {
        background: #fef9c3;
        color: #854d0e;
        border-color: #fef3c7;
      }
      .d1-chip.bad {
        background: #fee2e2;
        color: #991b1b;
        border-color: #fecaca;
      }

      .d1-chip.gray {
        background: #e5e7eb;
        color: #111827;
        border-color: #d1d5db;
      }

      /* Contenedor del cuerpo del panel D√≠a D (tabla) */
      #diaD-panel .d1-table-wrap {
        max-height: 420px;      /* antes seguro est√° m√°s chico, tipo 260px */
        overflow-y: auto;       /* scroll vertical interno */
        padding-right: 4px;     /* deja espacio para el scrollbar */
      }

      /* Opcional: que se note el √°rea de scroll */
      #diaD-panel .d1-table-wrap::-webkit-scrollbar {
        width: 6px;
      }
      #diaD-panel .d1-table-wrap::-webkit-scrollbar-thumb {
        background: #cbd5f5;
        border-radius: 999px;
      }

      /* Responsive m√≥vil */
      @media (max-width: 640px) {
        #diaD-panel {
          right: 8px;
          left: 8px;
          width: auto;
          max-width: none;
          top: 72px;
          max-height: 78vh;
        }
      }

      .d1-status {
        padding: 3px 8px;
        border-radius: 6px;
        font-size: 0.78rem;
        font-weight: 600;
        color: white;
      }

      .d1-status.red { background: #e11d48; }
      .d1-status.yellow { background: #eab308; color: #000; }
      .d1-status.orange { background: #f97316; }
      .d1-status.green { background: #22c55e; }
      .d1-status.gray { background: #6b7280; }

      .d1-status-hdr {
        cursor: move;
      }

      .dd-badge-acta{
        padding:3px 8px;border-radius:999px;font-weight:700;font-size:12px;
        background:#eef2ff;border:1px solid #c7d2fe;color:#1e3a8a;
      }


      #diaD-kpi-bar {
        position: fixed;
        top: 10px;
        left: calc(var(--sidebar-w) + 52px); /* despega de los botones +/- del mapa */
        width: min(780px, calc(100% - var(--sidebar-w) - 160px));
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        background: #f8fafc;
        padding: 4px 8px;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        box-shadow: 0 6px 14px rgba(15, 23, 42, 0.12);
        z-index: 4600;
        box-sizing: border-box;
      }

      /* Bot√≥n para mostrar el mapa/casillas */
      #btn-show-casillas {
        position: fixed;
        top: 100px;
        left: calc(var(--sidebar-w) + 52px);
        z-index: 4700;
        padding: 6px 10px;
        background: #7617c4;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 12px;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.25);
        cursor: pointer;
      }
      #btn-show-casillas:hover {
        background: #1f2937;
      }

      .kpi-box {
        background: white;
        padding: 4px 8px;
        border-radius: 6px;
        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        font-size: 12px;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-width: 78px;
        max-width: 90px;
      }

      .kpi-label {
        font-size: 10px;
        color: #64748b;
        text-transform: uppercase;
        margin-bottom: 1px;
      }

      /* Colores */
      .kpi-instaladas span:last-child { color: #d97706; font-weight: bold; }
      .kpi-incidencia span:last-child { color: #b45309; font-weight: bold; }
      .kpi-actas span:last-child { color: #059669; font-weight: bold; }
      .kpi-cerrada span:last-child { color: #334155; font-weight: bold; }
      .kpi-sinrep span:last-child { color: #b91c1c; font-weight: bold; }
      .kpi-avance span:last-child { color: #0ea5e9; font-weight: bold; }



      /* ===== Barra flotante de filtros D√≠a D ===== */
      #diaD-status-toolbar {
        position: absolute;
        top: 12px;
        right: 20px;
        display: flex;
        gap: 6px;
        padding: 4px 6px;
        background: #ffffff;
        border-radius: 999px;
        box-shadow: 0 12px 30px rgba(15, 23, 42, 0.25);
        z-index: 4600;
      }

      #diaD-status-toolbar button {
        border: none;
        outline: none;
        padding: 4px 8px;
        font-size: 11px;
        border-radius: 999px;
        cursor: pointer;
        background: #e5e7eb;
        color: #111827;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      #diaD-status-toolbar button:hover {
        background: #cbd5f5;
      }

      #diaD-status-toolbar button:active {
        transform: scale(0.97);
      }

      /* ===== Panel global de casillas por estatus ===== */
      #diaD-filter-panel {
        position: absolute;
        top: 60px;
        left: calc(var(--sidebar-w) + 40px);
        width: 620px;
        max-width: 96vw;
        max-height: 55vh;
        background: #ffffff;
        border-radius: 12px;
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.35);
        z-index: 4550;
        display: none;
        overflow: hidden;
      }

      #diaD-filter-panel .hdr {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 12px;
        background: linear-gradient(180deg, #f8fafc, #e5e7eb);
        border-bottom: 1px solid #e5e7eb;
      }

      #diaD-filter-panel .ttl {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      #diaD-filter-panel .ttl-main {
        font-weight: 700;
        font-size: 14px;
        color: #111827;
      }

      #diaD-filter-panel .ttl-sub {
        font-size: 11px;
        color: #6b7280;
      }

      #diaD-filter-panel .btn-close {
        border: none;
        background: #ffe7ea;
        color: #7f1d1d;
        width: 24px;
        height: 24px;
        border-radius: 8px;
        font-size: 16px;
        cursor: pointer;
      }

      #diaD-filter-panel .btn-close:hover {
        background: #fecaca;
      }

      #diaD-filter-panel .body {
        padding: 8px 10px 10px;
        max-height: calc(55vh - 40px);
        overflow: auto;
      }

      /* Tabla del panel de filtro */
      #diaD-filter-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }

      #diaD-filter-table th,
      #diaD-filter-table td {
        border-bottom: 1px solid #f1f5f9;
        padding: 6px 6px;
        text-align: left;
        vertical-align: top;
      }

      #diaD-filter-table th {
        position: sticky;
        top: 0;
        background: #ffffff;
        z-index: 1;
      }

      /* Reuse de selecci√≥n */
      #diaD-filter-table tbody tr.d1-row-selected {
        background: #e0f2fe;
      }
      #diaD-filter-table tbody tr.d1-row-selected td {
        border-bottom-color: #38bdf8;
      }

      /* Helper para ocultar/mostrar con clase */
      .diaD-filter-hidden {
        display: none;
      }

      .diaD-filter-btn {
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
        border: 1px solid #cbd5e1;
        background: #ffffff;
        color: #334155;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 4px;
      }

      .diaD-filter-btn:hover {
        background: #e5e7eb;
      }

      /* Cuando un filtro est√° activo */
      .diaD-filter-btn.active {
        background: #1d4ed8;
        color: #ffffff;
        border-color: #1d4ed8;
      }

            /* ===== Dashboard global D√≠a D ===== */
      #diaD-dashboard {
        position: absolute;
        bottom: 10px;
        left: calc(var(--sidebar-w) + 20px);
        right: 20px;
        z-index: 4600;
        display: none;            /* se muestra cuando haya datos */
        pointer-events: none;     /* para no estorbar el mapa, salvo en las cards */

        background: linear-gradient(90deg, #e5e9f0, #f9fafb);
        border-top: 1px solid #cbd5e1;
        box-shadow: 0 -4px 12px rgba(15,23,42,0.15);
        color: #93abe4;

      }

      #diaD-dashboard .dd-wrap {
        max-width: 720px;
        margin: 0 auto;
        background: rgba(132, 135, 141, 0.88);
        color: #e5e7eb;
        border-radius: 999px;
        padding: 6px 12px;
        box-shadow: 0 12px 30px rgba(15, 23, 42, 0.45);
        display: flex;
        align-items: center;
        gap: 10px;
        backdrop-filter: blur(6px);
      }

      #diaD-dashboard .dd-title {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: #114aad;
        white-space: nowrap;
      }

      #diaD-dashboard .dd-cards {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .dd-card {
        pointer-events: auto;     /* estas s√≠ son clickeables si luego las usamos */
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 11px;
        background: #0f172a;
        border: 1px solid #1e293b;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .dd-card span.dd-label {
        opacity: 0.85;
      }

      .dd-card span.dd-val {
        font-weight: 700;
      }

      /* Colores por estatus */
      .dd-total { border-color:#e5e7eb; }
      .dd-sinrep { background:#7f1d1d; border-color:#fecaca; color:#fee2e2; }
      .dd-instalada { background:#78350f; border-color:#facc15; color:#fef9c3; }
      .dd-incidencia { background:#9a3412; border-color:#fed7aa; color:#ffedd5; }
      .dd-acta { background:#14532d; border-color:#4ade80; color:#bbf7d0; }
      .dd-cerrada { background:#111827; border-color:#9ca3af; color:#e5e7eb; }

      @media (max-width: 900px){
        #diaD-dashboard .dd-wrap {
          flex-direction: column;
          align-items: flex-start;
          border-radius: 16px;
        }
      }

      /* ==== Captura de actas D√≠a D ==== */

      #diaD-acta-btn {
        position: absolute;
        bottom: 72px;         /* arriba del dashboard */
        left:150px;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #2563eb, #7c3aed);
        color: #fff;
        padding: 6px 14px;
        border-radius: 999px;
        font-size: 13px;
        font-weight: 600;
        box-shadow: 0 6px 14px rgba(15,23,42,.25);
        cursor: pointer;
        z-index: 4600;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      #diaD-acta-btn span.icon {
        font-size: 15px;
      }

      /* Ventana tipo ‚ÄúWindows‚Äù */
      #diaD-acta-modal {
        position: fixed;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        width: 520px;
        max-width: 90vw;
        background: #f9fafb;
        border-radius: 10px;
        box-shadow: 0 18px 40px rgba(15,23,42,.35);
        border: 1px solid #d1d5db;
        z-index: 4700;
        display: none;
      }

      #diaD-acta-modal .hdr {
        padding: 8px 12px;
        background: linear-gradient(90deg,#1e3a8a,#6366f1);
        color: white;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-radius: 10px 10px 0 0;
      }

      #diaD-acta-modal .hdr-title {
        font-size: 14px;
        font-weight: 600;
      }

      #diaD-acta-modal .hdr-actions {
        display: flex;
        gap: 6px;
      }

      #diaD-acta-modal .hdr-actions button {
        border: none;
        background: rgba(255,255,255,.15);
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 6px;
        cursor: pointer;
      }

      #diaD-acta-modal .hdr-actions button:hover {
        background: rgba(255,255,255,.30);
      }

      #diaD-acta-modal .body {
        padding: 10px 14px 12px;
        font-size: 13px;
        color: #111827;
      }

      #diaD-acta-modal .form-row {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
      }

      #diaD-acta-modal .form-row label {
        font-size: 12px;
        color: #4b5563;
      }

      #diaD-acta-modal input[type="text"],
      #diaD-acta-modal input[type="number"],
      #diaD-acta-modal select,
      #diaD-acta-modal textarea {
        width: 100%;
        padding: 5px 7px;
        border-radius: 6px;
        border: 1px solid #d1d5db;
        font-size: 13px;
        box-sizing: border-box;
      }

      #diaD-acta-modal textarea {
        resize: vertical;
        min-height: 50px;
      }

      #diaD-acta-modal .partidos-grid {
        display: grid;
        grid-template-columns: repeat(3,minmax(0,1fr));
        gap: 6px 10px;
        margin: 6px 0 4px;
      }

      #diaD-acta-modal .footer {
        margin-top: 8px;
        display: flex;
        justify-content: flex-end;
        gap: 8px;
      }

      #diaD-acta-modal .footer button {
        border-radius: 999px;
        border: none;
        cursor: pointer;
        font-size: 13px;
        padding: 6px 12px;
      }



      #diaD-acta-cancel {
        background: #e5e7eb;
        color: #374151;
      }

      #diaD-acta-save {
        background: #16a34a;
        color: white;
      }

      #diaD-acta-save:hover {
        background: #15803d;
      }




    </style>
  </head>
  <body>
    <div id="sec-info">
      <div class="hdr">
        <span class="ttl">Secci√≥n</span>
        <button id="sec-close" class="btn-close" aria-label="Cerrar">√ó</button>
      </div>
      <div class="body">
        <div class="row">
          <span class="k">Secci√≥n</span> <span class="v" id="si-sec">‚Äî</span>
        </div>
        <div class="row">
          <span class="k">Distrito Federal</span
          ><span class="v" id="si-df">‚Äî</span>
        </div>
        <div class="row">
          <span class="k">Distrito Local</span>
          <span class="v" id="si-dl">‚Äî</span>
        </div>
        <div class="row">
          <span class="k">LN (2024)</span> <span class="v" id="si-ln">‚Äî</span>
        </div>
      </div>
    </div>

    <div id="diaD-kpi-bar">
      <div class="kpi-box"><span class="kpi-label">Total</span><span id="kpi-total">0</span></div>
      <div class="kpi-box kpi-instaladas"><span class="kpi-label">Instaladas</span><span id="kpi-instaladas">0</span></div>
      <div class="kpi-box kpi-incidencia"><span class="kpi-label">Incidencia</span><span id="kpi-incidencia">0</span></div>
      <div class="kpi-box kpi-actas"><span class="kpi-label">Actas</span><span id="kpi-actas-rec">0</span></div>
      <div class="kpi-box kpi-cerrada"><span class="kpi-label">Cerradas</span><span id="kpi-cerradas">0</span></div>
      <div class="kpi-box kpi-sinrep"><span class="kpi-label">Sin Rep</span><span id="kpi-sinrep">0</span></div>
      <div class="kpi-box kpi-avance"><span class="kpi-label">% Avance</span><span id="kpi-avance">0%</span></div>
    </div>


       <!-- Panel D√≠a D: Secci√≥n ‚Üí Casillas -->
    <div id="diaD-panel">
      <div class="hdr">
        <div class="ttl">
          <div class="ttl-main">
            D√≠a "D" ¬∑ Secci√≥n <span id="d1-sec">‚Äî</span>
          </div>
          <div class="ttl-sub" id="d1-sub">
            Casillas: ‚Äî ¬∑ Reps asignados: ‚Äî ¬∑ Faltantes: ‚Äî
          </div>
        </div>
        <button id="d1-close" class="btn-close" aria-label="Cerrar">√ó</button>
      </div>

      <div class="body">
        <!-- KPIs superiores -->
      <div class="kpis">
        <div class="kpi">
          <div class="t">Casillas en la secci√≥n</div>
          <div class="v" id="d1-kpi-casillas">‚Äî</div>
        </div>

        <div class="kpi">
          <div class="t">Reps asignados</div>
          <div class="v" id="d1-kpi-reps">‚Äî</div>
        </div>

        <div class="kpi">
          <div class="t">Casillas con acta</div>
          <div class="v" id="d1-kpi-actas">‚Äî</div>
        </div>

        <div class="kpi">
          <div class="t">Casillas sin cobertura</div>
          <div class="v" id="d1-kpi-sin">‚Äî</div>
        </div>
      </div>


        <!-- Tabla de casillas con scroll interno -->
        <div class="d1-table-wrap">
          <table id="diaD-table">
            <thead>
              <tr>
                <th>Casilla</th>
                <th>Domicilio</th>
                <th>Representante</th>
                <th>Actas</th>
                <th>Estatus</th>
                <th>Seguimiento</th>
              </tr>
            </thead>
            <tbody id="d1-tbody">
              <!-- filas generadas por JS -->
            </tbody>
          </table>
        </div>
      </div>

      <!-- Asa de redimensionado (esquina inferior derecha) -->
      <div id="diaD-resize-handle"></div>
    </div>

      
    </div>

    <!-- Barra de tareas D√≠a D -->
    <div id="diaD-toolbar">
      <button id="btn-diaD-status">Estatus D√≠a "D" ‚ñæ</button>
      <div id="diaD-toolbar-menu" class="diaD-toolbar-menu hidden">
        <div data-est="todos">üìã Todas las casillas</div>
        <div data-est="sin_rep">‚ùå Sin representante</div>
        <div data-est="instalada">üü° Casilla instalada</div>
        <div data-est="incidencia">‚ö†Ô∏è Incidencia</div>
        <div data-est="acta_recibida">üü¢ Acta recibida</div>
        <div data-est="cerrada">‚¨õ Casilla cerrada</div>
      </div>
    </div>

    <!-- Panel global de estatus D√≠a D -->
    <div id="diaD-status-panel" class="diaD-status-panel hidden">
      <div class="hdr">
        <div class="ttl">
          <div class="ttl-main">
            Filtro D√≠a "D": <span id="d2-label">‚Äî</span>
          </div>
          <div class="ttl-sub" id="d2-sub">Casillas: ‚Äî</div>
        </div>
        <button id="d2-close" class="btn-close" aria-label="Cerrar">√ó</button>
      </div>
      <div class="body">
        <div style="font-size:12px; color:#64748b; margin-bottom:6px;">
          Haz clic en una fila para ir al punto de la casilla en el mapa.
        </div>
        <div class="d2-table-wrap">
          <table id="diaD-status-table">
            <thead>
              <tr>
                <th>Secci√≥n</th>
                <th>Casilla</th>
                <th>Domicilio</th>
                <th>Estatus</th>
              </tr>
            </thead>
            <tbody id="d2-tbody">
              <!-- Se rellena desde JS -->
            </tbody>
          </table>
        </div>
      </div>
    </div>


    <div class="d1-table-wrap">
      <table id="diaD-table">
        <thead>...</thead>
        <tbody id="d1-tbody"></tbody>
      </table>
    </div>


    <div id="panel-lateral">
      <div id="panel-header">
        <!-- <img src="assets/img/logo.png" alt="Logo"/> -->
        <span>Dia "D"</span>
      </div>
      <!-- Aqu√≠ va el contenido del panel lateral -->

      <!-- Buscador de secciones -->
      <div
        id="sec-search"
        style="
          padding: 10px 12px;
          border-top: 1px solid #cbd5e1;
          background: #eef2f7;
        "
      >
        <div style="display: flex; gap: 8px; align-items: center">
          <input
            id="sec-q"
            type="text"
            placeholder="Buscar secci√≥n (ej. 1234 o '1234 Le√≥n')"
            autocomplete="off"
            autocorrect="off"
            spellcheck="false"
            enterkeyhint="search"
            style="
              flex: 1;
              padding: 6px 8px;
              border: 1px solid #94a3b8;
              border-radius: 6px;
            "
          />
          <label style="white-space: nowrap; font-size: 12px">
            <input id="sec-global" type="checkbox" /> Todo el estado
          </label>
        </div>
        <ul
          id="sec-suggest"
          style="
            margin: 8px 0 0 0;
            padding: 0;
            list-style: none;
            max-height: 180px;
            overflow: auto;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            background: #fff;
            display: none;
          "
        ></ul>
      </div>

      <div
        id="mini-universe"
        style="
          padding: 12px 12px 6px 12px;
          background: #eef2f7;
          border-top: 1px solid #cbd5e1;
        "
      >
        <div class="row" style="margin-bottom: 8px">
          <label
            ><input type="checkbox" id="mini-all-state" /> Estado
            completo</label
          >
        </div>
        <div class="row" style="margin-bottom: 8px">
          <label>Municipio</label>
          <select id="mini-sel-mun" style="width: 100%; padding: 6px">
            <option value="">‚Äî Ninguno ‚Äî</option>
          </select>
        </div>
        <div class="row" style="margin-bottom: 8px">
          <label>Distrito Federal</label>
          <select id="mini-sel-df" style="width: 100%; padding: 6px">
            <option value="">‚Äî Ninguno ‚Äî</option>
          </select>
        </div>
        <div class="row" style="margin-bottom: 8px">
          <label>Distrito Local</label>
          <select id="mini-sel-dl" style="width: 100%; padding: 6px">
            <option value="">‚Äî Ninguno ‚Äî</option>
          </select>
        </div>
        <div class="hint" style="font-size: 12px; color: #64748b">
          Elige solo uno. Al cambiar, el mapa se actualiza.
        </div>
      </div>
    </div>
    <button id="btn-show-casillas" type="button">Mostrar casillas</button>
    <div id="map"></div>

    <!-- === SCRIPT √öNICO === -->
    <script>

      function ddNormSec(sec){
        return String(sec ?? '').replace(/\D+/g,'').padStart(4,'0');
      }
      function ddNormCas(cas){
        return String(cas ?? '').trim().toUpperCase().replace(/\s+/g,''); // quita espacios
      }
      function ddNormPuesto(p){
        return String(p ?? 'A').trim().toUpperCase().replace(/\s+/g,'');
      }
      function ddKey(sec, cas){
        const s = ddNormSec(sec);
        const c = ddNormCas(cas);
        return (typeof diaDKey === 'function') ? diaDKey(s, c) : `${s}|${c}`;
      }


      // ===== 0) Campos (ajusta si tus nombres son distintos) =====
      // DL = Distrito Local, DF = Distrito Federal
      const FIELD_KEYS = {
        mun: "MUNICIPIO",
        dl: "DISTRITO_L",
        df: "DISTRITO_F",
      };

      const paths = JSON.parse(localStorage.getItem("AT_PATHS") || "{}");
      const urlGeo = paths.geo || "data/geo/secciones.geojson";
      const catUrl = paths.catalog || "data/catalogo_territorial.json";
      const ELP = paths.electoral?.P || "data/electoral/P.json";
      // ...


     

      function cargarDiaDActas(){
        try{
          const raw = localStorage.getItem(DIA_D_ACTAS_STORAGE_KEY);
          DIA_D_ACTAS = raw ? JSON.parse(raw) : {};
        }catch(e){
          console.error('[D√≠a D] Error leyendo ACTAS:', e);
          DIA_D_ACTAS = {};
        }
      }



      function guardarDiaDActas(){
        try{
          localStorage.setItem(DIA_D_ACTAS_STORAGE_KEY, JSON.stringify(DIA_D_ACTAS));
        }catch(e){
          console.error('[D√≠a D] Error guardando ACTAS:', e);
        }
      }

      // helper
      function actaKey(sec, cas){
        return {
          sec: String(sec || '').trim(),
          cas: String(cas || '').trim()
        };
      }

      function getActasLabel(sec, cas){
        const s = String(sec).trim();
        const c = String(cas).trim().toUpperCase();
        const actas = window.diaDState?.[s]?.[c]?.actas || {};
        const keys = Object.keys(actas);
        if (!keys.length) return '';
        return keys.join(',');
      }



      // ===== D√≠a D: rutas y cach√© =====
      function getDiaDPath(){
        // Si alg√∫n d√≠a configuramos otra ruta en AT_PATHS, se respeta
        try{
          const paths = JSON.parse(localStorage.getItem('AT_PATHS') || '{}');
          if (paths.diaD) return paths.diaD;
        }catch(_){}

        // Por ahora, D√≠a D usa el mismo archivo que ESTRUCTURA (versi√≥n enriquecida)
        return 'data/casillas/casillas_min_por_seccion_enriquecido.json';
      }

      // === ESTADO DEL D√çA D ===
      let diaDState = {};       // memoria temporal
      let diaDStateLoaded = false;

      // Ruta del archivo (ajusta si tu estructura difiere)
      const DIA_D_STATE_PATH = "data/dia_d/dia_d_estado.json";

      // === Colores por partido (ajusta a tu paleta real) ===
      const DIA_D_PARTY_COLORS = {
        PAN: { border: '#004b8d', fill: '#c3daff' },
        PRI: { border: '#006b3f', fill: '#cdeee0' },
        PRD: { border: '#f6b800', fill: '#fff7cc' },
        MORENA: { border: '#6a1b1b', fill: '#f2d7d7' },
        PVEM: { border: '#1b5e20', fill: '#d2f5d4' },
        MC: { border: '#f57c00', fill: '#ffe0b2' },
        PT: { border: '#b71c1c', fill: '#ffcdd2' },
        // agrega los que necesites...
      };

      // === Helpers de ACTAS D√≠a D ===

      // Obtener el registro de una casilla en diaDState (o crear base)
      function ensureDiaDSlot(sec, casilla){
        const sKey = String(sec);
        const cKey = String(casilla);

        if (!diaDState[sKey]) diaDState[sKey] = {};
        if (!diaDState[sKey][cKey]) diaDState[sKey][cKey] = {
          estatus: 'sin_rep',
          actas: {}
        };

        return { slot: diaDState[sKey][cKey], sKey, cKey };
      }

      function getDiaDMarker(sec, cas){
        const s = String(sec).trim();
        const c = String(cas).trim().toUpperCase();
        const key = `${s}|${c}`;

        // Map
        if (window.DIA_D_MARKERS && typeof window.DIA_D_MARKERS.get === 'function'){
          return window.DIA_D_MARKERS.get(key) || null;
        }
        // Objeto anidado
        if (window.DIA_D_MARKERS?.[s]?.[c]) return window.DIA_D_MARKERS[s][c];

        return null;
      }


      // Guardar/actualizar un acta para una casilla y puesto
      // puesto: 'A', 'DL', 'DF', 'G', 'S', 'P', etc.
      // actaData: { ganador: 'PAN', ...otros campos que quieras guardar }
      function normSec(sec){
          return String(sec ?? '').replace(/\D+/g,'').padStart(4,'0');
        }
        function normCas(cas){
          return String(cas ?? '').trim().toUpperCase();
        }
        function normPuesto(p){
          return String(p ?? 'A').trim().toUpperCase();
        }




      // Saber si una casilla tiene al menos un acta capturada
      function hasAnyActa(sec, casilla){
        const sKey = String(sec);
        const cKey = String(casilla);
        const slot = diaDState[sKey]?.[cKey];
        const actas = slot?.actas || {};
        return Object.values(actas).some(a => !!a);
      }


      // Leer archivo de estado
      async function loadDiaDState(){
        if (diaDStateLoaded) return diaDState;

        try{
          const res = await fetch(DIA_D_STATE_PATH);
          if (!res.ok) throw new Error("No se pudo cargar dia_d_estado.json");
          diaDState = await res.json();
          diaDStateLoaded = true;
          console.log("[D√≠a D] Estado cargado:", diaDState);
        }catch(err){
          console.error("[D√≠a D] Error cargando estado:", err);
          diaDState = {};
        }
        return diaDState;
      }

      // Guardar estado (solo modo local)
      async function saveDiaDState(){
        console.warn("‚ö† saveDiaDState(): Solo funciona en entorno backend real. En local NO guarda.");
      }

            async function updateDiaDDashboard(){
        const box = document.getElementById('diaD-dashboard');
        if (!box) return;

        await ensureDiaDDataLoaded();   // usamos DIA_D_BY_SEC ya preparado

        // Reiniciamos contadores
        diaDStats = {
          total: 0,
          sin_rep: 0,
          instalada: 0,
          incidencia: 0,
          acta_recibida: 0,
          cerrada: 0
        };

        for (const [sec, arr] of DIA_D_BY_SEC.entries()){
          const secKey = String(sec).trim();
          const casKey = String(casillaId).trim().toUpperCase();

          if (!Array.isArray(arr)) continue;

          for (const c of arr){
            const casId  = (c.CASILLA_ID ?? c.CLAVE ?? c.CASILLA ?? '').toString();
            if (!casId) continue;

            const key    = diaDKey(secKey, casId);
            const saved  = diaDEstado[key] || {};

            const baseRaw   = normalizarEstatusDiaD(c.ESTATUS);
            const finalEst  = normalizarEstatusDiaD(saved.estatus || baseRaw);

            diaDStats.total += 1;

            if (finalEst in diaDStats){
              diaDStats[finalEst] += 1;
            } else {
              diaDStats.sin_rep += 1; // fallback
            }
          }
        }

        // Actualizar UI
        const fmt = n => Number(n).toLocaleString('es-MX');

        document.getElementById('dd-total')     .textContent = fmt(diaDStats.total);
        document.getElementById('dd-sinrep')    .textContent = fmt(diaDStats.sin_rep);
        document.getElementById('dd-instalada') .textContent = fmt(diaDStats.instalada);
        document.getElementById('dd-incidencia').textContent = fmt(diaDStats.incidencia);
        document.getElementById('dd-acta')      .textContent = fmt(diaDStats.acta_recibida);
        document.getElementById('dd-cerrada')   .textContent = fmt(diaDStats.cerrada);

        box.style.display = 'block';
      }

      // Obtener estatus de casilla
      function getDiaDEstatus(sec, casilla){
        const s = diaDState[String(sec)]?.[String(casilla)];
        return s?.estatus || "sin_rep";
      }

      // Actualizar estatus en memoria
      function setDiaDEstatus(sec, casilla, estatus){
        const secKey = String(sec);
        const casKey = String(casilla);
        const key    = diaDKey(secKey, casKey);

        if (!diaDState[secKey]) diaDState[secKey] = {};
        const prev = diaDState[secKey][casKey] || {};

        diaDState[secKey][casKey] = {
          ...prev,
          estatus
        };

        // Reflejar tambi√©n en el estado persistente (localStorage)
        const prevPersist = diaDEstado[key] || {};
        diaDEstado[key] = { ...prevPersist, estatus };
        guardarDiaDEstado();

        console.log("[D√≠a D] Nuevo estatus", secKey, casKey, estatus);
      }


            // PUESTOS que podemos marcar en el acta
      const DIA_D_PUESTOS = ['A', 'DL', 'DF', 'G', 'S', 'P'];

      function renderDiaDActasChips(secKey, casKey){
        try{
          const sec = String(secKey || '').trim();
          const cas = String(casKey || '').trim();
          if (!sec || !cas) return '';

          // Leemos del estado local de D√≠a D
          const secData  = (window.diaDState || {})[sec];
          const casData  = secData && secData[cas];
          const actas    = casData && casData.actas;

          if (!actas || typeof actas !== 'object') return '';

          const chips = [];

          for (const p of DIA_D_PUESTOS){
            if (actas[p]){
              const label = p.toUpperCase(); // A, DL, DF...
              chips.push(
                `<span class="d1-chip d1-chip-acta d1-chip-acta-${p.toLowerCase()}">${label}</span>`
              );
            }
          }

          return chips.join(' ');
        }catch(e){
          console.warn('[D√≠a D] Error renderizando actas', e);
          return '';
        }
      }



      // === ACTAS POR CASILLA Y PUESTO (A, DL, DF, S, G, P) =====================

      // Devuelve el objeto completo guardado para un acta
      function getDiaDActa(sec, casilla, puesto){
        const secKey = String(sec);
        const casKey = String(casilla);
        const pKey  = String(puesto || '').toUpperCase();

        const slot = diaDState[secKey]?.[casKey];
        if (!slot || !slot.actas) return null;

        return slot.actas[pKey] || null;
      }

      // Atajo: solo checar si hay acta capturada para ese puesto
      function hasDiaDActa(sec, casilla, puesto){
        return !!getDiaDActa(sec, casilla, puesto);
      }

      function getDiaDMarker(sec, cas) {
        const s = String(sec).trim();
        const c = String(cas).trim().toUpperCase();
        const key = `${s}|${c}`;

        // Caso 1: DIA_D_MARKERS es Map
        if (window.DIA_D_MARKERS && typeof window.DIA_D_MARKERS.get === 'function') {
          return window.DIA_D_MARKERS.get(key) || null;
        }

        // Caso 2: DIA_D_MARKERS es objeto anidado: DIA_D_MARKERS[sec][cas]
        if (window.DIA_D_MARKERS && window.DIA_D_MARKERS[s] && window.DIA_D_MARKERS[s][c]) {
          return window.DIA_D_MARKERS[s][c];
        }

        return null;
      }







      let DIA_D_RAW = null; // JSON bruto
      let DIA_D_BY_SEC = new Map(); // sec -> array de casillas

    async function ensureDiaDDataLoaded(){
      if (DIA_D_RAW && DIA_D_BY_SEC.size) return;

      const url = getDiaDPath();
      try{
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status} en D√≠a D`);
        const data = await res.json();
        DIA_D_RAW = data;

        const bySec = new Map();

        // Caso 1: un solo arreglo plano de casillas
        if (Array.isArray(data.casillas)){
          for (const c of data.casillas){
            const sec = String(c.SECCION ?? c.seccion ?? '').trim();
            if (!sec) continue;
            if (!bySec.has(sec)) bySec.set(sec, []);
            bySec.get(sec).push(c);
          }

        // Caso 2: objeto por secci√≥n { secciones: { "1481": { casillas:[...] } } }
        } else if (data.secciones && typeof data.secciones === 'object'){
          for (const [sec, payload] of Object.entries(data.secciones)){
            const arr = Array.isArray(payload.casillas) ? payload.casillas : [];
            bySec.set(String(sec).trim(), arr);
          }

        // ‚úÖ Caso 3: LO TUYO ‚Üí arreglo de secciones [{ SECCION: "...", casillas:[...] }, ...]
        } else if (Array.isArray(data)){
          for (const row of data){
            const sec = String(row.SECCION ?? row.seccion ?? '').trim();
            const arr = Array.isArray(row.casillas) ? row.casillas : [];
            if (!sec) continue;
            bySec.set(sec, arr);
          }
        }

        DIA_D_BY_SEC = bySec;
      }catch(err){
        console.error('[D√≠a D] Error cargando datos D√≠a D:', err);
        DIA_D_RAW = null;
        DIA_D_BY_SEC = new Map();
      }
    }

    function normalizarEstatusDiaD(raw){
      const s = (raw || '').toString().toLowerCase().trim();
      if (!s) return 'sin_rep';

      // Nuevos c√≥digos
      if (s === 'sin_rep' || s === 'sin representante') return 'sin_rep';
      if (s.startsWith('instal'))   return 'instalada';
      if (s.startsWith('inci'))     return 'incidencia';
      if (s === 'acta_recibida' || s.startsWith('acta')) return 'acta_recibida';
      if (s.startsWith('cerr'))     return 'cerrada';

      // Soporte a estatus viejos (por si los traes en el JSON)
      if (s === 'cubierta')                       return 'acta_recibida';
      if (s === 'parcial')                        return 'instalada';
      if (s === 'sin_cobertura' || s === 'sin cobertura') return 'sin_rep';

      return s;
    }

    function diaDStatusChip(c){
      // Estatus: primero lo que venga del objeto (ya mezclado con lo guardado),
      // en min√∫sculas para comparar f√°cil.
        const rawInput = c.ESTATUS ?? c.estatus ?? '';
      // üîπ Aqu√≠ s√≠ usamos el normalizador
        const raw = normalizarEstatusDiaD(rawInput);

      let label = '';
      let cls   = 'bad';  // color por defecto (rojo)

      switch (raw){
        case 'instalada':
          label = 'Instalada';
          cls   = 'mid';      // amarillo
          break;
        case 'incidencia':
          label = 'Incidencia';
          cls   = 'mid';      // tambi√©n amarillo / √°mbar
          break;
        case 'acta_recibida':
          label = 'Acta recibida';
          cls   = 'ok';       // verde
          break;
        case 'cerrada':
          label = 'Cerrada';
          cls   = 'gray';     // gris
          break;
        case 'sin_rep':
          label = 'Sin representante';
          cls   = 'bad';      // rojo
          break;
        default:
          // Si no hay estatus pero s√≠ rep ‚Üí chip verde
          const rep = (
            c.REP_NOMBRE ??
            c.REPRESENTANTE ??
            c.NOMBRE_REP ??
            c.REP ??
            c.NOMBRE ??
            ''
          ).toString().trim();

          if (rep){
            label = 'Cubierta';
            cls   = 'ok';
          } else {
            label = 'Sin dato';
            cls   = 'bad';
          }
          break;
      }

      return `<span class="d1-chip ${cls}">${label}</span>`;
    }


    // ===== Dashboard D√≠a D: m√©tricas globales =====
      let diaDStats = {
        total: 0,
        sin_rep: 0,
        instalada: 0,
        incidencia: 0,
        acta_recibida: 0,
        cerrada: 0
      };




      async function updateDiaDPanelForSection(sec, casillaId){
        const secKey = String(sec ?? '').trim().replace(/\D+/g,'').padStart(4,'0');
        const casKey = String(casillaId ?? '').trim().toUpperCase();

        const panel = document.getElementById('diaD-panel');
        if (!panel) return;

        await ensureDiaDDataLoaded();

        // ‚úÖ Tomar el Map correcto (a veces est√° en variable global, no en window)
      const bySecMap =
        (typeof DIA_D_BY_SEC !== 'undefined' && DIA_D_BY_SEC && typeof DIA_D_BY_SEC.get === 'function')
          ? DIA_D_BY_SEC
          : (window.DIA_D_BY_SEC && typeof window.DIA_D_BY_SEC.get === 'function')
            ? window.DIA_D_BY_SEC
            : null;

      let casillas = bySecMap ? (bySecMap.get(secKey) || []) : [];

      // üîÅ Fallback: si tu √≠ndice guarda la secci√≥n SIN padStart(4,'0')
      if (!casillas.length && bySecMap) {
        const altKey = String(sec ?? '').trim().replace(/\D+/g,''); // sin ceros a la izq
        casillas = bySecMap.get(altKey) || [];
      }


        // ===== KPI b√°sicos (solo total + reps) =====
        const totalCas = casillas.length;
        let repsAsig = 0;

        for (const c of casillas){
          const repBase = (
            c.REP_NOMBRE ??
            c.REPRESENTANTE ??
            c.NOMBRE_REP ??
            c.REP ??
            c.NOMBRE ??
            ''
          ).toString().trim();

          if (repBase) repsAsig += 1;
        }

        const elSec  = document.getElementById('d1-sec');
        const elCas  = document.getElementById('d1-kpi-casillas');
        const elReps = document.getElementById('d1-kpi-reps');
        const elAct  = document.getElementById('d1-kpi-actas'); // si existe, lo dejamos en 0
        const elSin  = document.getElementById('d1-kpi-sin');   // si existe, lo dejamos en 0

        if (elSec)  elSec.textContent  = secKey || '‚Äî';
        if (elCas)  elCas.textContent  = String(totalCas || 0);
        if (elReps) elReps.textContent = String(repsAsig || 0);
        if (elAct)  elAct.textContent  = '0';
        if (elSin)  elSin.textContent  = '0';

        const sub = document.getElementById('d1-sub');
        if (sub){
          sub.textContent = `Casillas: ${totalCas || 0} ¬∑ Reps asignados: ${repsAsig || 0}`;
        }

        // ===== Tabla (simple) =====
        const tbody = document.getElementById('d1-tbody');
        if (!tbody){
          panel.style.display = 'block';
          return;
        }

        if (!casillas.length){
          tbody.innerHTML = `
            <tr><td colspan="3" style="padding:10px 6px; color:#64748b;">
              No hay informaci√≥n de casillas D√≠a D para la secci√≥n ${secKey}.
            </td></tr>`;
        } else {
          tbody.innerHTML = casillas.map(c => {
            const casilla = (c.CASILLA ?? c.CLAVE ?? c.CASILLA_ID ?? '').toString().trim();
            const tipo    = (c.TIPO ?? '').toString().trim();
            const dom     = (c.DOMICILIO ?? '').toString().trim();

            const rep = (
              c.REP_NOMBRE ??
              c.REPRESENTANTE ??
              c.NOMBRE_REP ??
              c.REP ??
              c.NOMBRE ??
              ''
            ).toString().trim();

            const tel = (
              c.REP_TEL ??
              c.TELEFONO ??
              c.CELULAR ??
              c.TEL ??
              ''
            ).toString().trim();

            const casillaLabel = [casilla, tipo].filter(Boolean).join(' ¬∑ ');
            const repBlock = (rep || tel)
              ? `<div>${rep || '‚Äî'}</div><div style="color:#64748b;font-size:11px">${tel || ''}</div>`
              : '<span style="color:#9ca3af">Sin representante asignado</span>';

            // ID normalizado para enlazar click ‚Üí mapa
            const idAttr = (c.CASILLA_ID ?? c.CLAVE ?? c.CASILLA ?? '').toString().trim().toUpperCase();

            return `
              <tr data-casilla-id="${idAttr}">
                <td>${casillaLabel || '‚Äî'}</td>
                <td>${dom || '‚Äî'}</td>
                <td>${repBlock}</td>
              </tr>
            `;
          }).join('');
        }

        // Scroll y wrapper (igual que ten√≠as)
        const wrapper = tbody.parentElement;
        if (wrapper) {
          const scrollHost = wrapper.parentElement || wrapper;
          scrollHost.style.maxHeight = '420px';
          scrollHost.style.overflowY = 'auto';
          scrollHost.style.display   = 'block';
        }

        // Resaltar casilla espec√≠fica si viene desde el mapa
        if (casKey){
          const allRows = tbody.querySelectorAll('tr[data-casilla-id]');
          let targetRow = null;

          allRows.forEach(tr => {
            tr.classList.remove('d1-row-selected');
            const val = String(tr.getAttribute('data-casilla-id') || '').trim().toUpperCase();
            if (!targetRow && val === casKey){
              targetRow = tr;
            }
          });

          if (targetRow){
            targetRow.classList.add('d1-row-selected');
            targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }

        // Click en fila ‚Üí enfocar casilla en mapa
        const rows = tbody.querySelectorAll('tr[data-casilla-id]');
        rows.forEach(tr => {
          const cidNorm = String(tr.getAttribute('data-casilla-id') || '').trim().toUpperCase();
          tr.addEventListener('click', () => {
            if (!cidNorm) return;
            rows.forEach(r => r.classList.remove('d1-row-selected'));
            tr.classList.add('d1-row-selected');
            enfocarCasillaEnMapaDiaD(secKey, cidNorm);
          });
        });

        panel.style.display = 'block';
      }


      let diaDMenu = null;
      let diaDMenuSec = null;
      let diaDMenuCas = null;

      // Inicializar men√∫
      function initDiaDMenu(){
        diaDMenu = document.getElementById('diaD-menu-estatus');

        // Cuando haces clic en una opci√≥n del men√∫
        diaDMenu.addEventListener('click', async evt=>{
          const item = evt.target.closest('[data-est]');
          if (!item) return;

          const nuevoEst = item.dataset.est;

          console.log("‚û° Cambiar estatus:", diaDMenuSec, diaDMenuCas, nuevoEst);

          // Guardar en memoria
          setDiaDEstatus(diaDMenuSec, diaDMenuCas, nuevoEst);
          actualizarKPIsDiaD();


          // Refrescar panel
          await updateDiaDPanelForSection(diaDMenuSec, diaDMenuCas);

          // Refrescar el color del marcador
          enfocarCasillaEnMapaDiaD(diaDMenuSec, diaDMenuCas);

          ocultarDiaDMenu();
        });

        // Cerrar men√∫ si das clic fuera
        document.addEventListener('click', evt=>{
          if (!diaDMenu.contains(evt.target)) ocultarDiaDMenu();
        });
      }

      function mostrarDiaDMenu(x, y, sec, cas){
        diaDMenu.style.left = x + "px";
        diaDMenu.style.top  = y + "px";
        diaDMenuSec = sec;
        diaDMenuCas = cas;
        diaDMenu.classList.remove("hidden");
        diaDMenu.style.display = "block";   // üëà fuerza que se vea
      }

      function ocultarDiaDMenu(){
        diaDMenu.classList.add("hidden");
        diaDMenu.style.display = "none";    // üëà y aqu√≠ lo escondemos
      }

      document.addEventListener("DOMContentLoaded", initDiaDMenu);

      // ===== Panel global: casillas filtradas por estatus =====
      const DIA_D_STATUS_META = {
        sin_rep: {
          titulo: 'Casillas sin representante',
          icono:  '‚ùå'
        },
        instalada: {
          titulo: 'Casillas instaladas',
          icono:  'üü°'
        },
        incidencia: {
          titulo: 'Casillas con incidencia',
          icono:  '‚ö†Ô∏è'
        },
        acta_recibida: {
          titulo: 'Casillas con acta recibida',
          icono:  'üü¢'
        },
        cerrada: {
          titulo: 'Casillas cerradas',
          icono:  '‚¨õ'
        }
      };

      function abrirDiaDFilterPanel(estatusCanon){
        const panel = document.getElementById('diaD-filter-panel');
        const tbody = document.getElementById('diaD-filter-tbody');
        const ttl   = document.getElementById('diaD-filter-title');
        const sub   = document.getElementById('diaD-filter-sub');
        if (!panel || !tbody) return;

        const meta = DIA_D_STATUS_META[estatusCanon] || {
          titulo: 'Casillas',
          icono:  ''
        };

        ttl.textContent = `${meta.icono} ${meta.titulo}`.trim();

        (async () => {
          await ensureDiaDDataLoaded();

          const filas = [];
          let contador = 0;

          for (const [sec, casillas] of DIA_D_BY_SEC.entries()){
            const secKey = String(sec).trim();

            if (!secKey) continue;

            for (const c of casillas){
              const casillaId = (c.CASILLA_ID ?? c.CLAVE ?? c.CASILLA ?? '').toString().trim().toUpperCase();

              if (!casillaId) continue;

              const secKeyN = ddNormSec(secKey);
              const casKeyN = ddNormCas(casillaId);

              const key   = ddKey(secKeyN, casKeyN);
              const saved = (window.diaDEstado?.[key]) || {};

              const baseRaw = String(saved.estatus ?? c.ESTATUS ?? c.estatus ?? '');
              const canon   = normalizarEstatusDiaD(baseRaw);

              // ACTAS desde saved.actas
              const actasObj  = saved.actas || {};
              const actasList = Object.keys(actasObj).filter(k => actasObj[k]).map(k => String(k).toUpperCase());
              const actasTxt  = actasList.length ? actasList.join(',') : '';
              const actasHtml = actasTxt ? `<span class="dd-badge-acta">${actasTxt}</span>` : '';

              if (canon !== estatusCanon) continue;

              const casilla  = (c.CASILLA ?? c.CLAVE ?? casillaId).toString();
              const tipo     = (c.TIPO ?? '').toString();
              const dom      = (c.DOMICILIO ?? '').toString();

              const rep = (
                c.REP_NOMBRE ??
                c.REPRESENTANTE ??
                c.NOMBRE_REP ??
                c.REP ??
                c.NOMBRE ??
                ''
              ).toString().trim();

              const tel = (
                c.REP_TEL ??
                c.TELEFONO ??
                c.CELULAR ??
                c.TEL ??
                ''
              ).toString().trim();

              const casillaLabel = [casilla, tipo].filter(Boolean).join(' ¬∑ ');
              const repBlock = (rep || tel)
                ? `<div>${rep || '‚Äî'}</div><div style="color:#64748b;font-size:11px">${tel || ''}</div>`
                : '<span style="color:#9ca3af">Sin representante</span>';



 
              // leer estatus real desde diaDState (si existe)
              const slot = window.diaDState?.[secKey]?.[casillaId];
              const estatusReal = slot?.estatus || canon; // canon = lo que tra√≠as antes


              const cExt = { ...c, ESTATUS: estatusReal };

              let statusHtml;
              try {
                statusHtml = diaDStatusChip(cExt);
              } catch(e){
                console.error('[D√≠a D] Error en diaDStatusChip (filter panel):', e, cExt);
                statusHtml = '<span style="color:#9ca3af">‚Äî</span>';
              }

           console.log('[DD] actas debug', secKey, casillaId, saved.actas);
   

          filas.push(`
            <tr data-seccion="${secKey}" data-casilla-id="${casillaId}">
              <td>${secKey}</td>
              <td>${casillaLabel || '‚Äî'}</td>
              <td>${dom || '‚Äî'}</td>
              <td>${repBlock}</td>
              <td class="dd-td-actas">${actasHtml || ''}</td>
              <td class="dd-td-estatus">${statusHtml}</td>
            </tr>
          `);


              contador += 1;
            }
          }

          if (!filas.length){
            tbody.innerHTML = `
              <tr>
                <td colspan="6" style="padding:10px 6px; color:#64748b;">
                  No hay casillas con estatus "${meta.titulo.toLowerCase()}" en el universo actual.
                </td>
              </tr>
            `;
          } else {
            tbody.innerHTML = filas.join('');
          }

          if (sub){
            sub.textContent = `Casillas encontradas: ${contador}`;
          }

          // Wire de clic en filas ‚Üí zoom + detalle
          const allRows = tbody.querySelectorAll('tr[data-seccion][data-casilla-id]');
          allRows.forEach(tr => {
            tr.addEventListener('click', () => {
              allRows.forEach(f => f.classList.remove('d1-row-selected'));
              tr.classList.add('d1-row-selected');

              const sec = tr.getAttribute('data-seccion') || '';
              const cid = tr.getAttribute('data-casilla-id') || '';

              if (!sec || !cid) return;

              enfocarCasillaEnMapaDiaD(sec, cid);

              // Opcional: abre tambi√©n el panel de secci√≥n / casillas
              updateDiaDPanelForSection(sec, cid);
            });
          });

          panel.style.display = 'block';
          panel.classList.remove('diaD-filter-hidden');
        })().catch(err => {
          console.error('[D√≠a D] Error construyendo panel de filtro:', err);
        });
      }

      function cerrarDiaDFilterPanel(){
        const panel = document.getElementById('diaD-filter-panel');
        if (!panel) return;
        panel.style.display = 'none';
        panel.classList.add('diaD-filter-hidden');
      }

      function wireDiaDStatusToolbar(){
        const bar   = document.getElementById('diaD-status-toolbar');
        const btnX  = document.getElementById('diaD-filter-close');
        const panel = document.getElementById('diaD-filter-panel');
        const titlebar = document.getElementById('diaD-filter-titlebar');
        if (!bar) return;

        bar.addEventListener('click', ev => {
          const btn = ev.target.closest('button[data-diaD-estatus]');
          if (!btn) return;
          const est = btn.getAttribute('data-diaD-estatus');
          if (!est) return;
          abrirDiaDFilterPanel(est);
        });

        if (btnX){
          btnX.addEventListener('click', e => {
            e.preventDefault();
            cerrarDiaDFilterPanel();
          });
        }

        // Drag del panel de filtro
        if (panel && titlebar){
          let offsetX = 0, offsetY = 0, isDragging = false;
          titlebar.addEventListener("mousedown", (e) => {
            isDragging = true;
            // fija la posici√≥n actual en p√≠xeles para evitar el translate inicial
            const rect = panel.getBoundingClientRect();
            panel.style.transform = 'none';
            panel.style.left = rect.left + 'px';
            panel.style.top  = rect.top + 'px';
            offsetX = e.clientX - panel.offsetLeft;
            offsetY = e.clientY - panel.offsetTop;
            document.body.style.userSelect = "none";
          });
          document.addEventListener("mousemove", (e) => {
            if (!isDragging) return;
            panel.style.left = e.clientX - offsetX + "px";
            panel.style.top = e.clientY - offsetY + "px";
          });
          document.addEventListener("mouseup", () => {
            if (!isDragging) return;
            isDragging = false;
            document.body.style.userSelect = "auto";
          });
        }
      }

      // Se engancha junto con el resto de inicializaciones
      document.addEventListener('DOMContentLoaded', wireDiaDStatusToolbar);


      // Wire bot√≥n de cierre del panel D√≠a D
      // Wire bot√≥n de cierre + movimiento del panel D√≠a D
      (function wireDiaDPanel() {
        const panel = document.getElementById("diaD-panel");
        const btn = document.getElementById("d1-close");
        const handle = panel ? panel.querySelector(".hdr") : null;
        if (!panel || !btn || !handle) return;

        // Cerrar panel
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          panel.style.display = "none";
        });

        // --- Arrastrar panel ---
        let isDragging = false;
        let startX = 0;
        let startY = 0;
        let startLeft = 0;
        let startTop = 0;

        function onPointerDown(e) {
          // S√≥lo bot√≥n izquierdo del mouse / toque principal
          if (e.button !== undefined && e.button !== 0) return;

          // Si el click fue sobre el bot√≥n de cerrar, no arrastrar
          if (e.target.closest(".btn-close")) return;

          isDragging = true;
          const rect = panel.getBoundingClientRect();

          startX = e.clientX;
          startY = e.clientY;
          startLeft = rect.left;
          startTop = rect.top;

          // Pasamos de usar "right" a usar "left" al primer drag
          panel.style.right = "auto";
          panel.style.left = rect.left + "px";
          panel.style.top = rect.top + "px";

          document.addEventListener("pointermove", onPointerMove);
          document.addEventListener("pointerup", onPointerUp);
        }

        function onPointerMove(e) {
          if (!isDragging) return;

          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          let newLeft = startLeft + dx;
          let newTop = startTop + dy;

          // L√≠mites dentro de la ventana
          const margin = 8;
          const maxLeft = window.innerWidth - panel.offsetWidth - margin;
          const maxTop = window.innerHeight - panel.offsetHeight - margin;

          if (newLeft < margin) newLeft = margin;
          if (newTop < margin) newTop = margin;
          if (newLeft > maxLeft) newLeft = maxLeft;
          if (newTop > maxTop) newTop = maxTop;

          panel.style.left = newLeft + "px";
          panel.style.top = newTop + "px";
        }

        function onPointerUp() {
          if (!isDragging) return;
          isDragging = false;
          document.removeEventListener("pointermove", onPointerMove);
          document.removeEventListener("pointerup", onPointerUp);
        }

        handle.addEventListener("pointerdown", onPointerDown);

        // --- Redimensionar panel con el asa ---
        const resizeHandle = document.getElementById("diaD-resize-handle");
        if (resizeHandle && !resizeHandle.__wired) {
          let resizing = false;
          let startX = 0,
            startY = 0,
            startW = 0,
            startH = 0;

          const minW = 420;
          const minH = 400;

          const onResizeMove = (e) => {
            if (!resizing) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;

            const maxW = window.innerWidth - 20;
            const maxH = window.innerHeight - 20;

            const nextW = Math.min(Math.max(startW + dx, minW), maxW);
            const nextH = Math.min(Math.max(startH + dy, minH), maxH);

            panel.style.width = `${nextW}px`;
            panel.style.height = `${nextH}px`;
          };

          const onResizeUp = () => {
            if (!resizing) return;
            resizing = false;
            document.removeEventListener("pointermove", onResizeMove);
            document.removeEventListener("pointerup", onResizeUp);
            document.body.style.userSelect = "";
          };

          resizeHandle.addEventListener("pointerdown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            resizing = true;
            const rect = panel.getBoundingClientRect();
            startX = e.clientX;
            startY = e.clientY;
            startW = rect.width;
            startH = rect.height;

            // al primer resize trabajamos con left/top para mayor consistencia
            panel.style.left = rect.left + "px";
            panel.style.top = rect.top + "px";
            panel.style.right = "auto";
            panel.style.bottom = "auto";

            document.body.style.userSelect = "none";
            document.addEventListener("pointermove", onResizeMove);
            document.addEventListener("pointerup", onResizeUp);
          });

          resizeHandle.__wired = true;
        }
      })();

      // ===== 1) Mapa √∫nico y chequeo =====
      function ensureLeafletMap() {
        if (window.__AT_MAP && window.__AT_MAP instanceof L.Map)
          return window.__AT_MAP;
        const m = L.map("map", { zoomControl: true }).setView(
          [21.0, -101.3],
          7
        );
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "¬© OSM",
        }).addTo(m);
        window.__AT_MAP = m;
        return m;
      }
      function assertIsLeafletMap(m) {
        if (!(m instanceof L.Map) || typeof m.addLayer !== "function") {
          throw new Error(
            '[AT] addTo(): destino no es un Leaflet Map. Revisa variables llamadas "map" o dobles inicializaciones.'
          );
        }
      }

      let capaCasillasDiaD = null;
      let ultimoMarkerDiaD = null;
      let casillasCargadas = false;

      // ===== D√≠a D: estado persistente en localStorage =====
        const DIA_D_STORAGE_KEY = 'AT27_DIA_D_ESTADO_2027';
        let diaDEstado = {};  // { "1481|B1": { estatus: "instalada" }, ... }

        function cargarDiaDEstado(){
          try{
            const raw = localStorage.getItem(DIA_D_STORAGE_KEY);
            diaDEstado = raw ? JSON.parse(raw) : {};
          }catch(e){
            console.error('[D√≠a D] Error leyendo localStorage D√≠a D:', e);
            diaDEstado = {};
          }
        }

        function guardarDiaDEstado(){
          try{
            localStorage.setItem(DIA_D_STORAGE_KEY, JSON.stringify(diaDEstado));
          }catch(e){
            console.error('[D√≠a D] Error guardando localStorage D√≠a D:', e);
          }
        }

        // Helper para clave √∫nica secci√≥n+casilla
        function diaDKey(sec, casId){
          return `${sec}|${casId}`;
        }


      // key: "SECCION|CASILLA_ID" ‚Üí valor: layer de Leaflet
      const DIA_D_MARKERS = new Map();

      function getRepFromProps(p){
        return (
          p.REP_NOMBRE ??
          p.REPRESENTANTE ??
          p.NOMBRE_REP ??
          p.REP ??
          p.NOMBRE ??
          ''
        );
      }

      // --- Hacer movible el panel de filtros por estatus ---
    (function wireDiaDStatusPanel(){
      const panel  = document.getElementById('diaD-status-panel');   // üëà id de la ventana de status
      if (!panel) return;

      const handle = panel.querySelector('.d1-status-hdr');          // üëà header de la ventana
      if (!handle) return;

      let isDragging = false;
      let startX = 0, startY = 0;
      let startLeft = 0, startTop = 0;

      function onPointerDown(e){
        // s√≥lo bot√≥n izquierdo
        if (e.button !== undefined && e.button !== 0) return;

        // si haces clic en el bot√≥n X dentro del header, no arrastrar
        if (e.target.closest('.btn-close')) return;

        isDragging = true;

        const rect = panel.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        startLeft = rect.left;
        startTop = rect.top;

        // pasamos a usar left/top
        panel.style.right = 'auto';
        panel.style.left  = rect.left + 'px';
        panel.style.top   = rect.top  + 'px';

        document.addEventListener('pointermove', onPointerMove);
        document.addEventListener('pointerup', onPointerUp);
      }

      function onPointerMove(e){
        if (!isDragging) return;

        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        let newLeft = startLeft + dx;
        let newTop  = startTop  + dy;

        const margin  = 8;
        const maxLeft = window.innerWidth  - panel.offsetWidth  - margin;
        const maxTop  = window.innerHeight - panel.offsetHeight - margin;

        if (newLeft < margin)  newLeft = margin;
        if (newTop  < margin)  newTop  = margin;
        if (newLeft > maxLeft) newLeft = maxLeft;
        if (newTop  > maxTop)  newTop  = maxTop;

        panel.style.left = newLeft + 'px';
        panel.style.top  = newTop  + 'px';
      }

      function onPointerUp() {
        if (!isDragging) return;
        isDragging = false;
        document.removeEventListener('pointermove', onPointerMove);
        document.removeEventListener('pointerup', onPointerUp);
      }

      handle.addEventListener('pointerdown', onPointerDown);
    })();


      function getColorCasillaDiaD(p){
        // 1) Intentamos obtener secci√≥n y casilla desde props
        const sec = String(
          p.SECCION ??
          p.seccion ??
          p.Seccion ??
          p.ID ??
          p.id ??
          ''
        ).trim();

        const cas = String(
          p.CASILLA_ID ??
          p.CASILLA ??
          p.CLAVE ??
          ''
        ).trim();

        const slot = (sec && cas) ? (diaDState[sec]?.[cas] || null) : null;

        // 2) Si hay acta con ganador, pintamos por partido
        if (slot?.ganador){
          const party = String(slot.ganador).toUpperCase().trim();
          const palette = DIA_D_PARTY_COLORS[party];

          if (palette){
            return palette;
          }else{
            // Partido sin color definido ‚Üí gris neutro
            return {
              border: '#4b5563',
              fill:  '#e5e7eb'
            };
          }
        }

        // 3) Si no hay acta/ganador, usamos tu criterio de representante
        const rep = (getRepFromProps(p) || '').toString().trim();

        if (rep){
          // Casilla con representante asignado
          return {
            border: '#15803d',   // verde oscuro
            fill:  '#bbf7d0'     // verde muy claro
          };
        }else{
          // Casilla sin representante (sin cobertura)
          return {
            border: '#b91c1c',   // rojo oscuro
            fill:  '#fee2e2'     // rojo claro
          };
        }
      }




      async function cargarCapaCasillasDiaD() {
        console.log("[D√≠a D] Cargando capa de casillas‚Ä¶");

        // 1) Quitar capa anterior si existe
        if (window.capaCasillasDiaD) {
          try {
            window.capaCasillasDiaD.remove();
          } catch (_) {}
          window.capaCasillasDiaD = null;
        }

        // 2) Cargar archivo de casillas
        // üëá AJUSTA ESTA RUTA SOLO SI CAMBIA EL NOMBRE/UBICACI√ìN
        const url = "estrategico/data/casillas/puntos_casillas.geojson".replace("estrategico/","data/"); 
        // Si tu dia_D.html est√° en la carpeta 'estrategico', y el archivo est√° en
        // 'estrategico/data/casillas/puntos_casillas.geojson', la ruta relativa desde dia_D.html es:
        // "data/casillas/puntos_casillas.geojson".
        // Si ya confirmaste eso, puedes dejar simplemente:
        // const url = "data/casillas/puntos_casillas.geojson";

        let data;
        try {
          const res = await fetch("data/casillas/puntos_casillas.geojson");
          if (!res.ok) {
            console.error(`[D√≠a D] Error HTTP ${res.status} al cargar ${url}`);
            return;
          }
          data = await res.json();
        } catch (err) {
          console.error("[D√≠a D] Error casillas:", err);
          return;
        }

        // 3) Obtener secciones del UNIVERSO ACTUAL (capa de secciones filtrada)
        const base =
          (window.AT_CTX?.layer?.toGeoJSON?.()) ||
          window.AT_DATA ||
          { type: "FeatureCollection", features: [] };

        const universeSecs = new Set(
          (base.features || [])
            .map((f) => {
              const raw = String(
                f.properties?.ID ??
                f.properties?.SECCION ??
                f.properties?.id ??
                ""
              );
              return raw.replace(/\D+/g, "").padStart(4, "0");
            })
            .filter(Boolean)
        );

        console.log(
          "[D√≠a D] Secciones activas en universo:",
          universeSecs.size
        );

        // 4) Filtrar casillas seg√∫n las secciones del universo
        const filtered = {
          type: "FeatureCollection",
          features: (data.features || []).filter((feat) => {
            const p = feat.properties || {};
            const raw = String(
              p.SECCION ??
              p.seccion ??
              p.Seccion ??
              p.SEC ??
              p.SECC ??
              p.ID ??
              p.id ??
              ""
            );
            const id = raw.replace(/\D+/g, "").padStart(4, "0");
            return universeSecs.size ? universeSecs.has(id) : true;
          }),
        };

        console.log(
          "[D√≠a D] Casillas totales:",
          (data.features || []).length,
          "‚Üí visibles en universo:",
          filtered.features.length
        );

        // Aseguramos diccionario de marcadores
        if (!window.DIA_D_MARKERS) {
          window.DIA_D_MARKERS = {};
        } else {
          // limpiamos referencias previas
          window.DIA_D_MARKERS = {};
        }

        // 5) Crear capa Leaflet SOLO con casillas filtradas
        window.capaCasillasDiaD = L.geoJSON(filtered, {
          pointToLayer: (feat, latlng) => {
            const p = feat.properties || {};

          const secN = String(p.SECCION || p.seccion || p.Seccion || "").replace(/\D+/g,'').padStart(4,'0');
          const casN = String(p.CASILLA_ID || p.CASILLA || p.CLAVE || "").trim().toUpperCase();
          const colores = getColorCasillaDiaD(p, secN, casN);


            return L.circleMarker(latlng, {
              radius: 6,
              weight: 1.5,
              color: colores.border,
              fillColor: colores.fill,
              fillOpacity: 0.9,
            });
          },

            onEachFeature: (feat, layer) => {
              const p = feat.properties || {};

              // üîë Normalizaci√≥n (misma llave para TODO: mapa/panel/guardado)
              const secN = String(
                p.SECCION ||
                p.seccion ||
                p.Seccion ||
                ""
              ).replace(/\D+/g, '').padStart(4, '0');

              const casN = String(
                p.CASILLA_ID ||
                p.CASILLA ||
                p.CLAVE ||
                ""
              ).trim().toUpperCase();

              // ‚úÖ Indexar marcador con llaves normalizadas
              if (!window.DIA_D_MARKERS) window.DIA_D_MARKERS = {};
              if (!window.DIA_D_MARKERS[secN]) window.DIA_D_MARKERS[secN] = {};
              window.DIA_D_MARKERS[secN][casN] = layer;

              const domicilio = (p.DOMICILIO ?? p.DOM ?? p.DIRECCION ?? "").toString();
              const rep = (
                p.REP_NOMBRE ??
                p.REPRESENTANTE ??
                p.NOMBRE_REP ??
                p.REP ??
                p.NOMBRE ??
                ""
              ).toString();
              const tel = (
                p.REP_TEL ??
                p.TELEFONO ??
                p.CELULAR ??
                p.TEL ??
                ""
              ).toString();

              // Estatus: priorizamos lo guardado en diaDEstado, luego lo del geojson
              const key = (typeof diaDKey === 'function') ? diaDKey(secN, casN) : `${secN}|${casN}`;
              const estRaw = (diaDEstado?.[key]?.estatus) ?? p.ESTATUS ?? p.estatus ?? '';
              const estNorm = normalizarEstatusDiaD(estRaw);

              const popupHtml = `
                <div style="font-size:12px; line-height:1.35; min-width:220px;">
                  <div style="font-weight:700; color:#0f172a; margin-bottom:4px;">
                    Secci√≥n ${secN} ¬∑ Casilla ${casN}
                  </div>
                  <div><strong>Domicilio:</strong> ${domicilio || '‚Äî'}</div>
                  <div><strong>Rep:</strong> ${rep || '‚Äî'}${tel ? ' ¬∑ ' + tel : ''}</div>
                  <div><strong>Estatus:</strong> ${estNorm || 'sin_rep'}</div>
                </div>
              `;

              layer.bindPopup(popupHtml, { maxWidth: 280 });

              layer.on("click", () => {
                // Abre popup y enfoca en tabla/panel usando llaves normalizadas
                layer.openPopup();
                enfocarCasillaEnMapaDiaD(secN, casN);
              });
            },

        });

        // üîç Buscar el mapa Leaflet correcto
        const targetMap =
          (window.AT_CTX && window.AT_CTX.map) ||
          window.map;

        if (!targetMap || typeof targetMap.addLayer !== "function") {
          console.error(
            "[D√≠a D] No se encontr√≥ un mapa Leaflet v√°lido para agregar casillas."
          );
          return;
        }

        window.capaCasillasDiaD.addTo(targetMap);

        casillasCargadas = true;
        console.log("[D√≠a D] Capa de casillas actualizada seg√∫n universo.");
      }




      function enfocarCasillaEnMapaDiaD(sec, casillaId){
        const secKey = String(sec ?? '').trim();
        const cidKey = String(casillaId ?? '').trim();
        if (!secKey || !cidKey) return;

        const key = `${secKey}|${cidKey}`;
        const layer = DIA_D_MARKERS.get(key);
        if (!layer) {
          console.warn('[D√≠a D] No se encontr√≥ marcador para', key);
          return;
        }

      // dentro de cargarCapaCasillasDiaD()
      const atMap = ensureLeafletMap();
      assertIsLeafletMap(atMap);
      capaCasillasDiaD.addTo(atMap);

        

      // Quitar resaltado anterior
      if (ultimoMarkerDiaD && ultimoMarkerDiaD !== layer){
        const prevP   = ultimoMarkerDiaD.feature?.properties || {};
        const colPrev = getColorCasillaDiaD(prevP);
        ultimoMarkerDiaD.setStyle({
          radius: 6,
          weight: 1.5,
          color: colPrev.border,
          fillColor: colPrev.fill
        });
      }

      ultimoMarkerDiaD = layer;

      // Propiedades de la casilla actual
      const p = layer.feature?.properties || {};

      const secFromP = (p.SECCION || '').toString().trim();
      const casFromP = (
        p.CASILLA_ID ||
        p.CASILLA   ||
        p.CLAVE     ||
        ''
      ).toString().trim();

      const colores = getColorCasillaDiaD(
        p,
        secFromP || sec,        // prioriza lo que viene en props
        casFromP || casillaId   // y si no, usamos los argumentos de la funci√≥n
      );

      layer.setStyle({
        radius: 9,
        weight: 2.5,
        color: colores.border,
        fillColor: colores.fill
      });





        const latlng = layer.getLatLng();
        const currZ  = (typeof atMap.getZoom === 'function') ? atMap.getZoom() : 10;
        const targetZ = Math.max(currZ, 16); // acercamos m√°s al punto

        atMap.flyTo(latlng, targetZ, { duration: 0.45 });
      }


      function closeSecInfoPanel() {
        const box = document.getElementById("sec-info");
        if (box) box.style.display = "none";
        // Si quieres limpiar resaltado y etiquetas al cerrar:
        if (typeof clearSectionOverlays === "function") clearSectionOverlays();
      }

      function ensureSecInfoPanelWired() {
        const box = document.getElementById("sec-info");
        const hdr = box?.querySelector(".hdr");
        if (!box || !hdr || box.__wired) return;

        // Bloquear propagaci√≥n al mapa (no ‚Äúparpadea‚Äù al arrastrar)
        if (window.L && L.DomEvent) {
          L.DomEvent.disableClickPropagation(box);
          L.DomEvent.disableScrollPropagation(box);
        }

        // Drag del panel
        let dragging = false,
          sx = 0,
          sy = 0,
          bx = 0,
          by = 0;
        hdr.addEventListener("mousedown", (e) => {
          if (e.target.closest(".btn-close")) return; // no iniciar drag si clic en "√ó"
          e.preventDefault();
          e.stopPropagation();
          dragging = true;
          const r = box.getBoundingClientRect();
          sx = e.clientX;
          sy = e.clientY;
          bx = r.left;
          by = r.top;
          box.style.position = "absolute";
          box.style.right = "auto";
          box.style.bottom = "auto";
          document.body.style.userSelect = "none";
        });
        window.addEventListener("mousemove", (e) => {
          if (!dragging) return;
          e.preventDefault();
          e.stopPropagation();
          const dx = e.clientX - sx,
            dy = e.clientY - sy;
          box.style.left = bx + dx + "px";
          box.style.top = by + dy + "px";
        });
        window.addEventListener("mouseup", () => {
          if (!dragging) return;
          dragging = false;
          document.body.style.userSelect = "";
        });

        // Bot√≥n ‚Äú√ó‚Äù
        const btn = document.getElementById("sec-close");
        if (btn && !btn.__wired) {
          btn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeSecInfoPanel();
          });
          btn.__wired = true;
        }

        box.__wired = true;
      }

      // ===== 2) Filtrado por universo =====
      function toComp(v) {
        if (v == null) return "";
        const s = String(v).trim();
        return isFinite(s) && s !== "" ? Number(s) : s.toUpperCase();
      }
      function matches(props, u) {
        if (u.scope === "ALL") return true;
        const keyField =
          u.scope === "MUN"
            ? FIELD_KEYS.mun
            : u.scope === "DL"
            ? FIELD_KEYS.dl
            : FIELD_KEYS.df;
        return toComp(props?.[keyField]) === toComp(u.key);
      }
      function filterGeojson(geojson, u) {
        if (u.scope === "ALL") return geojson;
        const features = (geojson.features || []).filter((f) =>
          matches(f.properties, u)
        );
        return { ...geojson, features };
      }

      // ====== CARGA ELECTORAL (para obtener 24DL_LN) ======
      function getPaths() {
        try {
          return JSON.parse(localStorage.getItem("AT_PATHS") || "{}");
        } catch {
          return {};
        }
      }
      function getPuestoPath(p) {
        const paths = getPaths();
        return paths?.electoral?.[p] || `data/electoral/${p}.json`;
      }

      window.AT_ELECT = window.AT_ELECT || {};
      async function getElectData(puesto) {
        if (window.AT_ELECT[puesto]) return window.AT_ELECT[puesto];
        const res = await fetch(getPuestoPath(puesto));
        if (!res.ok) throw new Error(`HTTP ${res.status} en ${puesto}`);
        const js = await res.json();
        window.AT_ELECT[puesto] = js;
        return js;
      }
      // LN para 2024 desde DL; si no hay, intenta P (fallback)
      async function getLN24DL(sec) {
        const key = String(sec);
        try {
          const dl = await getElectData("DL");
          const ln = dl?.secciones?.[key]?.["2024"]?.LN;
          if (typeof ln === "number") return ln;
        } catch (_) {}
        try {
          const p = await getElectData("P");
          const ln = p?.secciones?.[key]?.["2024"]?.LN;
          if (typeof ln === "number") return ln;
        } catch (_) {}
        return null;
      }

      // ====== ADYACENCIAS (Turf) ======
      function bboxIntersects(b1, b2) {
        return !(
          b2[0] > b1[2] ||
          b2[2] < b1[0] ||
          b2[1] > b1[3] ||
          b2[3] < b1[1]
        );
      }
      function getAdjacents(feat) {
        const all =
          window.AT_DATA?.features ||
          window.AT_CTX?.layer?.toGeoJSON?.()?.features ||
          [];
        if (!all.length) return [];
        const b1 = turf.bbox(feat);
        const out = [];
        const sec1 = feat.properties?.SECCION;
        for (const f of all) {
          const p = f.properties || {};
          if (p.SECCION === sec1) continue;
          const b2 = turf.bbox(f);
          if (!bboxIntersects(b1, b2)) continue;
          try {
            if (
              turf.booleanTouches(feat, f) ||
              turf.booleanOverlap(feat, f) ||
              turf.booleanIntersects(feat, f)
            ) {
              out.push(f);
            }
          } catch (_) {}
        }
        return out.slice(0, 25); // cota de seguridad
      }

      // ====== LABELS SOBRE EL MAPA ======
      function addLabelForFeature(feat, className, text) {
        try {
          const c = turf.centerOfMass(feat).geometry.coordinates; // [lon, lat]
          const m = L.marker([c[1], c[0]], {
            icon: L.divIcon({ className, html: text, iconSize: [0, 0] }),
          });
          window.__SEC_LABELS =
            window.__SEC_LABELS || L.layerGroup().addTo(ensureLeafletMap());
          window.__SEC_LABELS.addLayer(m);
          return m;
        } catch (_) {}
        return null;
      }

      function clearSectionOverlays() {
        const atMap = ensureLeafletMap();
        if (window.__SEC_HL) {
          try {
            atMap.removeLayer(__SEC_HL);
          } catch (_) {}
          window.__SEC_HL = null;
        }
        if (window.__SEC_ADJ) {
          try {
            atMap.removeLayer(__SEC_ADJ);
          } catch (_) {}
          window.__SEC_ADJ = null;
        }
        if (window.__SEC_LABELS) {
          try {
            atMap.removeLayer(__SEC_LABELS);
          } catch (_) {}
          window.__SEC_LABELS = null;
        }
      }

      // Dibuja selecci√≥n + adyacentes + labels
      function paintSelectionAndAdj(feat) {
        const atMap = ensureLeafletMap();
        clearSectionOverlays();

        // resaltado principal
        window.__SEC_HL = L.geoJSON(feat, {
          style: { color: "#e91e63", weight: 3, fillOpacity: 0.25 },
        }).addTo(atMap);
        try {
          atMap.fitBounds(window.__SEC_HL.getBounds(), { padding: [28, 28] });
        } catch (_) {}

        // adyacentes
        const adj = getAdjacents(feat);
        if (adj.length) {
          window.__SEC_ADJ = L.geoJSON(
            { type: "FeatureCollection", features: adj },
            {
              style: {
                color: "#90a4ae",
                weight: 1.2,
                dashArray: "4,4",
                fillOpacity: 0.05,
              },
            }
          ).addTo(atMap);
        }

        // labels
        const sec = feat.properties?.SECCION ?? "‚Äî";
        addLabelForFeature(feat, "sec-label", `Secci√≥n ${sec}`);
        for (const f of adj) {
          const s2 = f.properties?.SECCION ?? "‚Äî";
          addLabelForFeature(f, "sec-label-adj", s2);
        }
      }

      // ====== PANEL FLOTANTE (drag + datos) ======

      async function showSectionInfo(feat) {
        ensureSecInfoPanelWired();
        const p = feat.properties || {};
        const sec = p.SECCION ?? "‚Äî";
        const df = p[FIELD_KEYS.df] ?? "‚Äî";
        const dl = p[FIELD_KEYS.dl] ?? "‚Äî";

        // LN 24DL_LN
        let ln = await getLN24DL(sec);
        if (ln == null) ln = "‚Äî";

        // Pintar panel peque√±o
        const box = document.getElementById("sec-info");
        box.querySelector(".hdr").textContent = `Secci√≥n ${sec}`;
        document.getElementById("si-sec").textContent = sec;
        document.getElementById("si-df").textContent = df;
        document.getElementById("si-dl").textContent = dl;
        document.getElementById("si-ln").textContent = ln;
        box.style.display = "block";

        // >>> NUEVO: actualizar panel D√≠a D con casillas de la secci√≥n
        if (sec && sec !== "‚Äî") {
          updateDiaDPanelForSection(sec);
        }
      }

      // ENTER + CLIC + ULTIMO TOKEN

      function currentNeedle(q) {
        if (!q) return "";
        const parts = String(q)
          .split(/[,;\s]+/)
          .filter(Boolean);
        return parts.length ? parts[parts.length - 1] : "";
      }

      // ===== Mini-selector de universo dentro del m√≥dulo =====
      let __mini = { selMun: null, selDf: null, selDl: null, all: null };

      function uniqueSorted(values) {
        const arr = values.map((v) => String(v ?? "").trim()).filter(Boolean);
        const set = Array.from(new Set(arr));
        return set.sort((a, b) =>
          isFinite(a) && isFinite(b)
            ? Number(a) - Number(b)
            : a.localeCompare(b, "es")
        );
      }
      function buildMiniOptions(raw) {
        const feats = raw.features || [];
        const grab = (k) => uniqueSorted(feats.map((f) => f.properties?.[k]));
        return {
          mun: grab(FIELD_KEYS.mun),
          df: grab(FIELD_KEYS.df),
          dl: grab(FIELD_KEYS.dl),
        };
      }
      function fillSelect(sel, arr) {
        sel.innerHTML =
          '<option value="">‚Äî Ninguno ‚Äî</option>' +
          arr.map((v) => `<option value="${v}">${v}</option>`).join("");
      }
      function getMiniUniverse() {
        const { selMun, selDf, selDl, all } = __mini;
        if (all.checked)
          return { scope: "ALL", key: null, label: "Estado completo" };
        if (selMun.value)
          return {
            scope: "MUN",
            key: selMun.value,
            label: `Municipio ${selMun.options[selMun.selectedIndex].text}`,
          };
        if (selDf.value)
          return {
            scope: "DF",
            key: selDf.value,
            label: `Distrito Federal ${selDf.value}`,
          };
        if (selDl.value)
          return {
            scope: "DL",
            key: selDl.value,
            label: `Distrito Local ${selDl.value}`,
          };
        return null;
      }
      function miniExclusivity(which) {
        const { selMun, selDf, selDl, all } = __mini;
        if (which === "ALL") {
          selMun.value = "";
          selDf.value = "";
          selDl.value = "";
        }
        if (which === "MUN") {
          selDf.value = "";
          selDl.value = "";
          all.checked = false;
        }
        if (which === "DF") {
          selMun.value = "";
          selDl.value = "";
          all.checked = false;
        }
        if (which === "DL") {
          selMun.value = "";
          selDf.value = "";
          all.checked = false;
        }
        applyMiniUniverse();
      }
      function applyMiniUniverse() {
        const u2 = getMiniUniverse();
        if (!u2) return;
        // 1) Persistir
        localStorage.setItem(
          "AT_UNIVERSE",
          JSON.stringify({ ...u2, ts: Date.now() })
        );
        // 2) Redibujar con el nuevo universo usando el raw ya cargado
        const atMap = ensureLeafletMap();
        const filtered2 = filterGeojson(window.AT_DATA, u2);
        if (window.AT_CTX?.layer) {
          atMap.removeLayer(AT_CTX.layer);
        }
        const layer2 = L.geoJSON(filtered2, {
          style: { color: "#7d0025", weight: 1.2, fillOpacity: 0.15 },
        }).addTo(atMap);
        try {
          atMap.fitBounds(layer2.getBounds(), { padding: [20, 20] });
        } catch (e) {}
        window.AT_CTX = {
          ...(window.AT_CTX || {}),
          universe: u2,
          layer: layer2,
        };
        // 3) Header
        const hdr = document.querySelector("#panel-header span");
        if (hdr) {
          hdr.textContent = `An√°lisis Territorial ¬∑ ${u2.label}`;
        }
        refreshSectionSearch(u2);

          // Re-dibujar casillas filtradas solo si ya se cargaron
         if (casillasCargadas) cargarCapaCasillasDiaD();

      }
      function initMiniSelector(raw, u) {
        // Guardar el geojson bruto para futuros re-filtros
        window.AT_DATA = raw;

        __mini.selMun = document.getElementById("mini-sel-mun");
        labelMunicipiosFromCatalog("#mini-sel-mun");

        __mini.selDf = document.getElementById("mini-sel-df");
        __mini.selDl = document.getElementById("mini-sel-dl");
        __mini.all = document.getElementById("mini-all-state");

        const opt = buildMiniOptions(raw);
        fillSelect(__mini.selMun, opt.mun);
        fillSelect(__mini.selDf, opt.df);
        fillSelect(__mini.selDl, opt.dl);

        // Reflejar el universo actual
        if (u.scope === "ALL") {
          __mini.all.checked = true;
        }
        if (u.scope === "MUN") {
          __mini.selMun.value = String(u.key);
        }
        if (u.scope === "DF") {
          __mini.selDf.value = String(u.key);
        }
        if (u.scope === "DL") {
          __mini.selDl.value = String(u.key);
        }

        async function labelMunicipiosFromCatalog(selectId) {
          const sel = document.querySelector(selectId);
          if (!sel) return;

          // 1) Ruta del cat√°logo desde el Portal (AT_PATHS) o fallback
          let catUrl = "data/catalogo_territorial.json";
          try {
            const paths = JSON.parse(localStorage.getItem("AT_PATHS") || "{}");
            if (paths?.catalog) catUrl = paths.catalog;
          } catch {}

          // 2) Cargar cat√°logo
          let cat = null;
          try {
            const r = await fetch(catUrl);
            if (!r.ok) throw new Error("HTTP " + r.status);
            cat = await r.json();
          } catch (e) {
            console.warn("[AT] No se pudo cargar el cat√°logo:", e);
            return; // salimos sin tocar etiquetas
          }

          const mapa = cat?.municipios || {};
          // helper: si el cat√°logo trae ceros a la izquierda en las llaves
          const getName = (code) => {
            const s = String(code);
            return (
              mapa[s] ||
              mapa[s.padStart(2, "0")] ||
              mapa[s.padStart(3, "0")] ||
              s
            );
          };

          // 3) Reetiquetar opciones (sin cambiar value)
          for (const opt of sel.options) {
            if (!opt.value) continue; // deja "‚Äî Ninguno ‚Äî"
            const name = getName(opt.value);
            opt.text = `${opt.value} ‚Äî ${name}`;
          }
        }

        // Eventos (auto-ejecuta)
        __mini.selMun.addEventListener("change", () => miniExclusivity("MUN"));
        __mini.selDf.addEventListener("change", () => miniExclusivity("DF"));
        __mini.selDl.addEventListener("change", () => miniExclusivity("DL"));
        __mini.all.addEventListener("change", () => miniExclusivity("ALL"));
      }

      // Nombre fijo del campo (texto) del municipio
      const MUN_NAME_KEY = "MUNICIPIO";

      // Detecta autom√°ticamente el campo de C√ìDIGO de municipio (si no, usa el nombre)
      function detectMunCodeKey(raw) {
        const feats = raw.features || [];
        const candidates = [
          "MUN",
          "CVE_MUN",
          "CLV_MUN",
          "ID_MUN",
          "MUNICIPIO_ID",
          "MUNICIPIO_CVE",
          "CVE_MUNICIPIO",
          "CVE_MPIO",
        ];
        for (const k of candidates) {
          const ok = feats.some((f) => {
            const v = f.properties?.[k];
            return (
              v != null &&
              String(v).trim() !== "" &&
              String(v).toUpperCase() !== "NULL"
            );
          });
          if (ok) return k;
        }
        return null; // fallback ser√° MUN_NAME_KEY
      }

      // ‚Äî‚Äî Utils de texto ‚Äî‚Äî
      function _norm(s) {
        if (s == null) return "";
        return String(s)
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .toUpperCase()
          .trim();
      }
      function _isDigits(s) {
        return /^[0-9]+$/.test(String(s || ""));
      }

      // ‚Äî‚Äî Nombre de municipio desde cat√°logo (si existe) ‚Äî‚Äî
      function getMunNameFromCatalog(code) {
        const cat = window.AT_CATALOG;
        if (!cat?.municipios) return String(code ?? "");
        const s = String(code);
        // maneja posibles ceros a la izquierda
        return (
          cat.municipios[s] ||
          cat.municipios[s.padStart(2, "0")] ||
          cat.municipios[s.padStart(3, "0")] ||
          s
        );
      }

      // ‚Äî‚Äî √çndice de secciones ‚Äî‚Äî
      let __SEC_INDEX = { items: [], global: false };

      function buildSectionIndex(raw, universe, useGlobal) {
        const feats = raw?.features || [];
        const munKey = window.AT_KEYS?.munCode || FIELD_KEYS.mun;
        const items = [];

        // dataset base: global = todas, local = filtradas por universo
        const base = useGlobal
          ? feats
          : filterGeojson(raw, universe).features || [];

        for (const f of base) {
          const p = f.properties || {};
          const sec = p.SECCION ?? p.Seccion ?? p.seccion ?? null;
          if (sec == null) continue;

          const munCode = p[munKey];
          const munName = getMunNameFromCatalog(munCode);
          const df = p[FIELD_KEYS.df];
          const dl = p[FIELD_KEYS.dl];

          // texto para b√∫squeda
          const text = `${sec} ${munCode ?? ""} ${munName ?? ""} ${df ?? ""} ${
            dl ?? ""
          }`;
          // bounds (si multiparte, Leaflet lo resuelve)
          let bounds = null;
          try {
            bounds = L.geoJSON(f).getBounds();
          } catch (_) {}

          items.push({
            sec: String(sec).trim(),
            munCode: munCode,
            munName: munName,
            df,
            dl,
            feature: f,
            textNorm: _norm(text),
            bounds,
          });
        }

        __SEC_INDEX = { items, global: !!useGlobal };
      }

      function searchSections(query, limit = 15) {
        const q = _norm(query);
        if (!q) return [];
        const ds = __SEC_INDEX.items || [];

        // Heur√≠stica:
        // - si es num√©rico puro: prioridad a SECCION que empiece con q
        // - si no: busca por texto
        if (_isDigits(q)) {
          const starts = ds.filter(it => _norm(it.sec).startsWith(q));
          const contains = ds.filter(
            it => !starts.includes(it) && _norm(it.sec).includes(q)
          );
          return [...starts, ...contains].slice(0, limit);
        } else {
          const tokens = q.split(/\s+/).filter(Boolean);
          return ds
            .filter(it => tokens.every(t => it.textNorm.includes(t)))
            .slice(0, limit);
        }
      }


      // ‚Äî‚Äî UI de sugerencias ‚Äî‚Äî
      let __SEC_HIGHLIGHT = null;

      function renderSecSuggestions(list) {
        const ul = document.getElementById("sec-suggest");
        if (!ul) return;
        if (!list.length) {
          ul.style.display = "none";
          ul.innerHTML = "";
          return;
        }

        ul.innerHTML = list
          .map((it) => {
            const label = `${it.sec} ‚Äî ${
              it.munName || it.munCode || ""
            }`.replace(/\s+-\s+$/, "");
            const meta = [];
            if (it.dl != null) meta.push(`DL ${it.dl}`);
            if (it.df != null) meta.push(`DF ${it.df}`);
            const sub = meta.length
              ? `<small style="color:#64748b">${meta.join(" ¬∑ ")}</small>`
              : "";
            return `<li data-sec="${it.sec}" style="padding:6px 8px; border-bottom:1px solid #e5e7eb; cursor:pointer">
                    <div>${label}</div>${sub}
                  </li>`;
          })
          .join("");
        ul.style.display = "block";
      }

      function gotoSection(item) {
        const atMap = window.AT_CTX?.map || ensureLeafletMap();

        // 1) Resolver el feature de la secci√≥n
        const sec = String(item.sec ?? item.SECCION ?? "");
        let feat = item.feature;

        if (!feat) {
          const feats =
            window.AT_CTX?.layer?.toGeoJSON?.().features ||
            window.AT_DATA?.features ||
            [];
          feat = feats.find((f) => String(f.properties?.SECCION) === sec);
        }

        if (!feat) {
          console.warn(
            "[AT] No encontr√© el feature para la secci√≥n",
            sec,
            item
          );
          return;
        }

        // 2) Pintar selecci√≥n + adyacentes + labels (esto limpia overlays previos)
        paintSelectionAndAdj(feat);

        // 3) Mostrar panel con DF, DL y LN (24DL_LN)
        showSectionInfo(feat);

        // 4) Feedback visual (parpadeo leve sobre el highlight actual)
        const hl = window.__SEC_HL;
        if (hl && typeof hl.setStyle === "function") {
          try {
            hl.setStyle({ weight: 4 });
            setTimeout(() => {
              try {
                hl.setStyle({ weight: 3 });
              } catch (_) {}
            }, 220);
          } catch (_) {}
        }

        // 5) Oculta la lista de sugerencias (si est√° visible)
        const ul = document.getElementById("sec-suggest");
        if (ul) ul.style.display = "none";
      }

      // Delegaci√≥n de clic en las sugerencias (una sola vez)
      (function wireSectionSearchEventsOnce() {
        const ul = document.getElementById("sec-suggest");
        const input = document.getElementById("sec-q");
        if (!ul || !input) return;

        // Si est√° dentro de un form, evita submit al Enter
        const form = input.closest("form");
        form?.addEventListener("submit", (e) => e.preventDefault());

        // Clic en cualquier <li data-sec="...">
        if (!ul.__wiredClick) {
          ul.addEventListener("click", (ev) => {
            const li = ev.target.closest("li[data-sec]");
            if (!li) return;
            const sec = li.getAttribute("data-sec");
            const item = (__SEC_INDEX?.items || []).find(
              (x) => String(x.sec) === String(sec)
            );
            if (item) gotoSection(item);
            ul.style.display = "none";
          });
          ul.__wiredClick = true;
        }

        // Enter en el input = ir al primer resultado + abrir panel D√≠a D
      if (!input.__wiredKey) {
        input.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter") {
            ev.preventDefault(); // evita submit/autocomplete

            const raw    = (input.value || "").trim();
            const needle = currentNeedle(raw);
            const digits = raw.replace(/\D+/g, "");
            let handled  = false;

            // 1) Coincidencia EXACTA por n√∫mero de secci√≥n usando el √≠ndice
            if (digits && window.__SEC_INDEX && Array.isArray(window.__SEC_INDEX.items)) {
              const ds = window.__SEC_INDEX.items;
              const exact = ds.find((it) => {
                const secStr = String(it.sec);
                return (
                  secStr === digits ||
                  secStr.padStart(4, "0") === digits.padStart(4, "0")
                );
              });
              if (exact) {
                gotoSection(exact);   // pinta + showSectionInfo(feat) + panel D√≠a D
                handled = true;
              }
            }

            // 2) Si no hubo coincidencia exacta, usar b√∫squeda normal
            if (!handled && typeof searchSections === "function" && window.__SEC_INDEX) {
              const [first] = searchSections(needle, 1);
              if (first) {
                gotoSection(first);   // pinta + showSectionInfo(feat)
                handled = true;
              }
            }

            // 3) Fallback: buscar directamente en el GeoJSON si no hay √≠ndice o no hubo match
            if (!handled) {
              const secKey = (digits || needle || "").replace(/\D+/g, "");
              if (secKey) {
                const base =
                  (window.AT_CTX?.layer?.toGeoJSON?.()) ||
                  window.AT_DATA ||
                  { type: "FeatureCollection", features: [] };

                const feats = base.features || [];
                const feat = feats.find((f) => {
                  // Prioriza SECCION; ID en el GeoJSON est√° 0-indexado, as√≠ evitamos saltos de +1
                  const rawId = String(
                    f.properties?.SECCION ??
                    f.properties?.id ??
                    f.properties?.ID ??
                    ""
                  );
                  const id = rawId.replace(/\D+/g, "");
                  return (
                    id === secKey ||
                    id.padStart(4, "0") === secKey.padStart(4, "0")
                  );
                });

                if (feat) {
                  // Igual que gotoSection, pero directo, por si algo falla en el √≠ndice
                  paintSelectionAndAdj(feat);
                  showSectionInfo(feat); // aqu√≠ se dispara el panel D√≠a D para esa secci√≥n
                }
              }
            }

            // En cualquier caso cerramos la lista de sugerencias
            ul.style.display = "none";
          }

          if (ev.key === "Escape") {
            ul.style.display = "none";
          }
        });
        input.__wiredKey = true;
      }



        // Input: recalcula sugerencias usando el "√∫ltimo token"
        if (!input.__wiredInput) {
          input.addEventListener("input", () => {
            const needle = currentNeedle(input.value);
            renderSecSuggestions(searchSections(needle, 15));
          });
          input.__wiredInput = true;
        }
      })();

      // ‚Äî‚Äî Inicializar Buscador en el m√≥dulo ‚Äî‚Äî
      function initSectionSearch(raw, universe) {
        const input = document.getElementById("sec-q");
        const list = document.getElementById("sec-suggest");
        const globalC = document.getElementById("sec-global");
        if (!input || !list) return;

        // construir √≠ndice (por universo actual)
        buildSectionIndex(raw, universe, !!globalC?.checked);

        // Cambiar √°mbito (global / universo actual)
        globalC?.addEventListener("change", () => {
          buildSectionIndex(raw, universe, !!globalC.checked);
          // refresca sugerencias con la query actual
          if (input.value) {
            renderSecSuggestions(searchSections(input.value, 15));
          }
        });
      }

      // ‚Äî‚Äî Cuando cambies de universo con tu mini-selector, reindexa ‚Äî‚Äî
      function refreshSectionSearch(universe) {
        const input = document.getElementById("sec-q");
        const globalC = document.getElementById("sec-global");
        if (!window.AT_DATA || !input) return;
        buildSectionIndex(window.AT_DATA, universe, !!globalC?.checked);
        if (input.value) {
          renderSecSuggestions(searchSections(input.value, 15));
        }
      }

      function limpiarFormularioActaDiaD(){
        document.querySelectorAll('.acta-votos-input').forEach(i=>i.value='');
        ['diaD-acta-nulos','diaD-acta-total','diaD-acta-incidencia']
          .forEach(id=>{ const el=document.getElementById(id); if(el) el.value='';});
      }
      document.getElementById('diaD-acta-casilla')
        ?.addEventListener('change', limpiarFormularioActaDiaD);

        


      function getEffectiveStatusForCasilla(secKey, c){
        const idAttr = (c.CASILLA_ID ?? c.CLAVE ?? c.CASILLA ?? '').toString();
        const key    = diaDKey(secKey, idAttr);
        const saved  = diaDEstado[key];

        const raw = (saved?.estatus ?? c.ESTATUS ?? c.estatus ?? '').toString();
        return normalizarEstatusDiaD(raw);
      }

      async function buildDiaDStatusList(filterEst){
        await ensureDiaDDataLoaded();
        const rows = [];

        for (const [secKey, arr] of DIA_D_BY_SEC.entries()){
          for (const c of arr){
            const est = getEffectiveStatusForCasilla(secKey, c);
            if (filterEst !== 'todos' && est !== filterEst) continue;

            const cas = (c.CASILLA ?? c.CLAVE ?? '').toString();
            const dom = (c.DOMICILIO ?? '').toString();

            rows.push({ sec: secKey, cas, dom, est });
          }
        }
        return rows;
      }

      async function abrirDiaDStatusPanel(filterEst){
        const panel   = document.getElementById('diaD-status-panel');
        const tbody   = document.getElementById('d2-tbody');
        const labelEl = document.getElementById('d2-label');
        const subEl   = document.getElementById('d2-sub');
        if (!panel || !tbody) return;

        const labels = {
          todos:        'Todas las casillas',
          sin_rep:      'Sin representante',
          instalada:    'Casilla instalada',
          incidencia:   'Con incidencia',
          acta_recibida:'Acta recibida',
          cerrada:      'Casilla cerrada'
        };

        labelEl.textContent = labels[filterEst] || filterEst;

        const rows = await buildDiaDStatusList(filterEst);
        subEl.textContent = `Casillas encontradas: ${rows.length}`;

        if (!rows.length){
          tbody.innerHTML = `
            <tr><td colspan="4" style="padding:8px; color:#64748b;">
              No hay casillas con este estatus.
            </td></tr>`;
        } else {
          tbody.innerHTML = rows.map(r => `
            <tr data-sec="${sec}" data-cas="${casillaId}">
              <td>${r.sec}</td>
              <td>${r.cas}</td>
              <td>${r.dom || '‚Äî'}</td>
              <td>${diaDStatusChip(r.est)}</td>
            </tr>
          `).join('');
        }

        // Clic en fila ‚Üí zoom al punto de la casilla
        const trs = tbody.querySelectorAll('tr[data-sec][data-cas]');
        trs.forEach(tr => {
          tr.addEventListener('click', () => {
            const sec = tr.getAttribute('data-sec');
            const cas = tr.getAttribute('data-cas');
            enfocarCasillaEnMapaDiaD(sec, cas);
          });
        });

        panel.classList.remove('hidden');
        panel.style.display = 'block';
      }

      function initDiaDToolbar(){
        const btn   = document.getElementById('btn-diaD-status');
        const menu  = document.getElementById('diaD-toolbar-menu');
        const panel = document.getElementById('diaD-status-panel');
        const btnClose = document.getElementById('d2-close');

        if (!btn || !menu || !panel || !btnClose) return;

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const visible = !menu.classList.contains('hidden');
          if (visible){
            menu.classList.add('hidden');
          } else {
            menu.classList.remove('hidden');
          }
        });

        // Clic en opci√≥n de men√∫
        menu.addEventListener('click', (evt) => {
          const item = evt.target.closest('[data-est]');
          if (!item) return;
          const est = item.dataset.est;
          menu.classList.add('hidden');
          abrirDiaDStatusPanel(est);
        });

        // Cerrar panel global
        btnClose.addEventListener('click', () => {
          panel.classList.add('hidden');
        });

        // Cerrar men√∫ si haces clic fuera
        document.addEventListener('click', (evt) => {
          if (!menu.contains(evt.target) && evt.target !== btn){
            menu.classList.add('hidden');
          }
        });
      }





      function getRawForIndex() {
        // Usa el dataset completo si ya lo cacheaste
        if (window.AT_DATA) return window.AT_DATA;
        // Si no, al menos usa lo ya pintado en el mapa
        const lyr = window.AT_CTX?.layer;
        return lyr && typeof lyr.toGeoJSON === "function"
          ? lyr.toGeoJSON()
          : null;
      }

      // ===== ACTAS D√çA D: modelo simple =====

      // Ajusta esta lista a los partidos que quieras capturar
      const DIA_D_PARTIDOS = [
        'PAN',
        'PRI',
        'PRD',
        'PVEM',
        'MC',
        'MORENA',
        'PT',
        'PANAL'
      ];

      const DIA_D_ACTAS_STORAGE_KEY = 'AT27_DIA_D_ACTAS_2027';

      // Estructura: { "SECCION|CASILLA": { sec, casilla, votos:{PAN:123,...}, nulos, total, incidencia } }
      let DIA_D_ACTAS = {};

      function keyActa(sec, cas){
        return `${String(sec).trim()}|${String(cas).trim().toUpperCase()}`;
      }

      function cargarActasDiaD(){
        try{
          const raw = localStorage.getItem(DIA_D_ACTAS_STORAGE_KEY);
          DIA_D_ACTAS = raw ? JSON.parse(raw) : {};
        }catch(e){
          console.error('[D√≠a D] Error leyendo actas de localStorage:', e);
          DIA_D_ACTAS = {};
        }
      }


      // Construye la cuadr√≠cula de partidos dentro de #diaD-acta-partidos-grid
      function buildActasPartidosGrid(){
        const cont = document.getElementById('diaD-acta-partidos-grid');
        if (!cont) return;

        cont.innerHTML = DIA_D_PARTIDOS.map(p => `
          <div style="display:flex; flex-direction:column; gap:2px; flex:1 1 120px;">
            <label style="font-size:11px; color:#4b5563;">${p}</label>
            <input
              type="number"
              min="0"
              step="1"
              data-partido="${p}"
              class="acta-votos-input"
              style="padding:4px 6px; border-radius:6px; border:1px solid #cbd5e1; font-size:13px;"
            />
          </div>
        `).join('');
      }

      // Limpia el formulario
      function limpiarFormularioActa(){
        document.getElementById('diaD-acta-sec').value = '';
        document.getElementById('diaD-acta-casilla').value = '';
        document.getElementById('diaD-acta-nulos').value = '0';
        document.getElementById('diaD-acta-total').value = '0';
        document.getElementById('diaD-acta-incidencia').value = '';

        document.querySelectorAll('.acta-votos-input').forEach(inp => {
          inp.value = '';
        });
      }

      // Carga un acta guardada (si existe) en el formulario
      function cargarActaEnFormulario(sec, cas){
        const k = keyActa(sec, cas);
        const acta = DIA_D_ACTAS[k];

        // Siempre actualizar secci√≥n y casilla en el formulario
        const secInput = document.getElementById('acta-sec-input');
        const casInput = document.getElementById('acta-casilla-input');
        const incInput = document.getElementById('acta-incidencias');

        if (secInput) secInput.value = sec;
        if (casInput) casInput.value = cas;
        if (incInput) incInput.value = '';

        // Siempre limpiar votos antes de cargar algo
        document.querySelectorAll('.acta-votos-input').forEach(inp => {
          inp.value = '';
        });

        // Si NO hay acta guardada para esa secci√≥n/casilla, dejamos todo vac√≠o
        if (!acta) return;

        // Si S√ç hay acta, rellenamos
        if (incInput) incInput.value = acta.incidencias || '';

        document.querySelectorAll('.acta-votos-input').forEach(inp => {
          const p = inp.dataset.partido;
          inp.value = acta.votos?.[p] ?? '';
        });
      }


  // Guarda el acta del formulario en memoria + localStorage (BASELINE LIMPIO)
    function guardarActaDesdeFormulario(){
      const sec = document.getElementById('diaD-acta-sec').value.trim();
      const cas = document.getElementById('diaD-acta-casilla').value.trim().toUpperCase();
      const nulos = Number(document.getElementById('diaD-acta-nulos').value || 0);
      const total = Number(document.getElementById('diaD-acta-total').value || 0);
      const inc = document.getElementById('diaD-acta-incidencia').value.trim();

      // ‚úÖ puesto (A/DL/DF/S/G/P)
      const puesto = (document.getElementById('dd-acta-puesto')?.value || 'A').toUpperCase();

      if (!sec || !cas){
        alert('Captura la secci√≥n y la casilla antes de guardar.');
        return;
      }

      // ‚úÖ votos por partido
      const votos = {};
      document.querySelectorAll('.acta-votos-input').forEach(inp => {
        const p = inp.dataset.partido;
        const v = inp.value.trim();
        votos[p] = v === '' ? null : Number(v);
      });

      // ‚úÖ Calcular ganador
      let ganador = null;
      let maxV = -Infinity;

      Object.entries(votos).forEach(([part, val]) => {
        const n = (val === null || Number.isNaN(val)) ? null : Number(val);
        if (n !== null && n > maxV) {
          maxV = n;
          ganador = part;
        }
      });

      // Empate exacto (opcional)
      if (ganador !== null) {
        const top = Object.entries(votos)
          .filter(([_, v]) => v !== null && Number(v) === maxV)
          .map(([p]) => p);

        if (top.length > 1) ganador = 'EMPATE';
      }

      const k = keyActa(sec, cas);

      DIA_D_ACTAS[k] = {
        sec,
        casilla: cas,
        puesto,
        votos,
        nulos,
        total,
        incidencia: inc,
        ganador
      };

      guardarActasDiaD();

      console.log('[D√≠a D] Acta guardada (BASE):', k, DIA_D_ACTAS[k]);
      alert('Acta guardada correctamente.');
    }



      // Zoom a la secci√≥n desde el formulario
      function zoomSeccionDesdeActa(){
        const sec = document.getElementById('diaD-acta-sec').value.trim();
        if (!sec) return;

        const feats = (window.AT_DATA?.features || []);
        const feat = feats.find(f => String(f.properties?.SECCION) === sec);

        if (!feat){
          alert(`No encontr√© la secci√≥n ${sec} en el universo actual.`);
          return;
        }

        // Reutilizamos tu l√≥gica de selecci√≥n + adyacentes
        paintSelectionAndAdj(feat);
        showSectionInfo(feat);   // si quieres ver tambi√©n el panel peque√±o
      }




      function guardarActasDiaD(){
        try{
          
        }catch(e){
          console.error('[D√≠a D] Error guardando actas en localStorage:', e);
          console.error("[D√≠a D] Error guardando ACTAS:", error);
        }
      }

      function wireActasForm(){
        // Construir la cuadricula de partidos
        buildActasPartidosGrid();

        const btnGuardar = document.getElementById('diaD-acta-save');
        const btnCancelar = document.getElementById('diaD-acta-cancel');
        const secInput = document.getElementById('diaD-acta-sec');
        const casSelect = document.getElementById('diaD-acta-casilla');

        if (btnGuardar){
          btnGuardar.addEventListener('click', (e) => {
            e.preventDefault();
            guardarActaDesdeFormulario();
          });
        }

        if (btnCancelar){
          btnCancelar.addEventListener('click', (e) => {
            e.preventDefault();
            // S√≥lo limpiar, NO cerramos por si quiere corregir
            limpiarFormularioActa();
          });
        }

        // Enter en secci√≥n ‚Üí zoom
        if (secInput){
          secInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter'){
              e.preventDefault();
              zoomSeccionDesdeActa();
            }
          });

          // Cuando cambia la secci√≥n, intentamos rellenar casillas desde D√≠a D
          secInput.addEventListener('blur', () => {
            rellenarCasillasParaSeccion(secInput.value.trim());
          });
        }

        // Si eliges una casilla del select y ya hay acta guardada, la cargamos
        if (casSelect){
          casSelect.addEventListener('change', () => {
            const sec = secInput.value.trim();
            const cas = casSelect.value.trim().toUpperCase();
            if (sec && cas){
              cargarActaEnFormulario(sec, cas);
            }
          });
        }

          const casInput = document.getElementById('acta-casilla-input');
          if (casInput){
            casInput.addEventListener('change', () => {
              const sec = document.getElementById('acta-sec-input').value.trim();
              const cas = casInput.value.trim().toUpperCase();
              if (!sec || !cas) return;
              cargarActaEnFormulario(sec, cas);
            });
          }

      }

      // Rellenar el <select> de casillas usando los datos D√≠a D ya cargados
      function rellenarCasillasParaSeccion(sec){
        const sel = document.getElementById('diaD-acta-casilla');
        if (!sel) return;

        const secKey = String(sec || '').trim();
        if (!secKey){
          sel.innerHTML = '<option value="">‚Äî Selecciona despu√©s de la secci√≥n ‚Äî</option>';
          return;
        }

        // Usamos el mapa de casillas que ya construiste: DIA_D_BY_SEC
        const casillas = DIA_D_BY_SEC.get(secKey) || [];
        if (!casillas.length){
          sel.innerHTML = '<option value="">(Sin casillas D√≠a D para esta secci√≥n)</option>';
          return;
        }

        sel.innerHTML = '<option value="">‚Äî Elige casilla ‚Äî</option>' +
          casillas.map(c => {
            const id  = (c.CASILLA_ID ?? c.CASILLA ?? c.CLAVE ?? '').toString().trim();
            const tip = (c.TIPO ?? '').toString().trim();
            const label = [id, tip].filter(Boolean).join(' ¬∑ ');
            return `<option value="${id}">${label}</option>`;
          }).join('');
      }

      // Mostrar mapa y capa de casillas solo cuando el usuario lo solicite
      async function mostrarMapaCasillas(){
        const mapEl = document.getElementById('map');
        if (!mapEl) return;

        mapEl.classList.remove('map-hidden');

        const map = ensureLeafletMap();
        setTimeout(() => map.invalidateSize(), 50);

        if (!casillasCargadas){
          await cargarCapaCasillasDiaD().catch(err => console.error('[D√≠a D] Error casillas:', err));
          casillasCargadas = true;
        }
      }


      // ===== 3) Boot =====
      document.addEventListener("DOMContentLoaded", async () => {
        // a) Leer universo y rutas puestos en el PORTAL
        const u = JSON.parse(localStorage.getItem("AT_UNIVERSE") || "null");
        const paths = JSON.parse(
          localStorage.getItem("AT_PATHS") || '{"geo":""}'
        );
        if (!u) {
          const hdr = document.querySelector("#panel-header span");
          hdr && (hdr.textContent += " ¬∑ selecciona el universo en el Portal");
          setTimeout(() => {
            location.href = "portal.html";
          }, 600);
          return;
        }

        // b) Etiqueta del universo
        const hdr = document.querySelector("#panel-header span");
        hdr && (hdr.textContent += ` ¬∑ ${u.label}`);

        // c) Mapa √∫nico
        const atMap = ensureLeafletMap();
        assertIsLeafletMap(atMap);

        // d) Cargar y filtrar GeoJSON
        const url = paths.geo || "data/geo/secciones.geojson"; // <-- ajusta si tu ruta difiere

        // Cargar cat√°logo territorial (para nombres visibles)
        const catUrl =
          (paths.catalog && paths.catalog.trim()) ||
          "/data/catalogo_territorial.json";
        let catalog = window.AT_CATALOG || null;
        if (!catalog) {
          try {
            const rc = await fetch(catUrl);
            if (!rc.ok)
              throw new Error(`HTTP ${rc.status} al cargar cat√°logo ${catUrl}`);
            catalog = await rc.json();
            window.AT_CATALOG = catalog;
          } catch (err) {
            console.warn("[AT] No se pudo cargar el cat√°logo de nombres:", err);
            window.AT_CATALOG = catalog = null; // seguimos sin nombres amigables
          }
        }

        let raw = window.AT_DATA || null; // usa cach√© si ya existe
        if (!raw) {
          try {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status} al cargar ${url}`);
            raw = await res.json(); // ‚úÖ solo una vez
            window.AT_DATA = raw; // ‚úÖ guarda en cach√© aqu√≠
          } catch (err) {
            console.error("[AT] Error cargando GeoJSON:", err);
            alert("No se pudo cargar el GeoJSON");
            return;
          }
        }
        // a partir de aqu√≠, usa 'raw'

        const filtered = filterGeojson(raw, u);
        console.log(
          "[AT] Universo:",
          u,
          "Total:",
          raw.features?.length || 0,
          "Filtradas:",
          filtered.features?.length || 0
        );

        if (!filtered.features || filtered.features.length === 0) {
          console.warn(
            "[AT] No hay geometr√≠as para el universo seleccionado:",
            u
          );
          alert("No hay datos para el universo seleccionado");
        }

        // Nombre fijo del campo (texto) del municipio
        const MUN_NAME_KEY = "MUNICIPIO";

        // Detecta campo de C√ìDIGO (si existe); si no, usa el de nombre
        function detectMunCodeKey(raw) {
          const feats = raw.features || [];
          const candidates = [
            "MUN",
            "CVE_MUN",
            "CLV_MUN",
            "ID_MUN",
            "MUNICIPIO_ID",
            "MUNICIPIO_CVE",
            "CVE_MUNICIPIO",
            "CVE_MPIO",
          ];
          for (const k of candidates) {
            if (feats.some((f) => (f.properties?.[k] ?? "") !== "")) return k;
          }
          return null;
        }

        const munCodeKey = detectMunCodeKey(raw) || MUN_NAME_KEY; // fallback: nombre
        FIELD_KEYS.mun = munCodeKey;
        window.AT_KEYS = { munCode: munCodeKey, munName: MUN_NAME_KEY };

        // e) Dibujar capa
        const layer = L.geoJSON(filtered, {
          style: { color: "#000000", weight: 1.2, fillOpacity: 0.15 },
          onEachFeature: (feat, lyr) => {
            const p = feat.properties || {};
            const muni = p[FIELD_KEYS.mun] ?? "‚Äî";
            const dl = p[FIELD_KEYS.dl] ?? "‚Äî";
            const df = p[FIELD_KEYS.df] ?? "‚Äî";
            lyr.bindPopup(
              `<b>Secci√≥n</b>: ${
                p.SECCION ?? "‚Äî"
              }<br><b>Mun</b>: ${muni}<br><b>DL</b>: ${dl}<br><b>DF</b>: ${df}`
            );
            lyr.on("mouseover", () => lyr.setStyle({ weight: 2 }));
            lyr.on("mouseout", () => lyr.setStyle({ weight: 1.2 }));
          },
        }).addTo(atMap);

        try {
          atMap.fitBounds(layer.getBounds(), { padding: [20, 20] });
        } catch (e) {}
        window.AT_CTX = { universe: u, paths, map: atMap, layer };

        function getMunNameFromCatalog(code) {
          const cat = window.AT_CATALOG;
          if (!cat?.municipios) return String(code ?? "");
          return cat.municipios[String(code)] || String(code ?? "");
        }
        function getDfListFromCatalog(feats) {
          return window.AT_CATALOG?.distritos_federales &&
            window.AT_CATALOG.distritos_federales.length
            ? window.AT_CATALOG.distritos_federales
            : uniqSorted(feats.map((f) => f.properties?.[FIELD_KEYS.df]));
        }
        function getDlListFromCatalog(feats) {
          return window.AT_CATALOG?.distritos_locales &&
            window.AT_CATALOG.distritos_locales.length
            ? window.AT_CATALOG.distritos_locales
            : uniqSorted(feats.map((f) => f.properties?.[FIELD_KEYS.dl]));
        }
        initMiniSelector(raw, u);
        initSectionSearch(window.AT_DATA || raw, u);

                // Cargar estado D√≠a D desde localStorage al iniciar
        cargarDiaDEstado();

                // Actas D√≠a D
        cargarActasDiaD();    // lee de localStorage
        wireActasForm();      // arma la cuadricula y eventos del formulario


      });

      (function wireATHotkeys() {
        if (window.__AT_HOTKEYS) return;
        window.__AT_HOTKEYS = true;

        window.addEventListener("keydown", (e) => {
          // Esc: cerrar panel
          if (e.key === "Escape") {
            if (document.getElementById("sec-info")?.style.display !== "none") {
              e.preventDefault();
              closeSecInfoPanel();
            }
          }
          // Ctrl+K (o Cmd+K en Mac): enfocar buscador de secciones
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "k") {
            e.preventDefault();
            document.getElementById("sec-q")?.focus();
          }
        });
      })();

      // Cargar estado D√≠a D desde localStorage al iniciar
        cargarDiaDEstado();
        cargarDiaDActas();



        // ====== UTILIDAD: lista plana global de casillas D√≠a D ======
      function buildDiaDFlatList(){
        const out = [];
        if (!DIA_D_BY_SEC || !(DIA_D_BY_SEC instanceof Map)) return out;

        for (const [sec, casillas] of DIA_D_BY_SEC.entries()){
          for (const c of casillas){
            const secKey = String(sec).trim();
            const casKey = String(casillaId).trim().toUpperCase();

            const casId  = (c.CASILLA_ID ?? c.CLAVE ?? c.CASILLA ?? '').toString().trim();
            if (!secKey || !casId) continue;

            const dom = (c.DOMICILIO ?? '').toString();
            const rep = (
              c.REP_NOMBRE ??
              c.REPRESENTANTE ??
              c.NOMBRE_REP ??
              c.REP ??
              c.NOMBRE ??
              ''
            ).toString().trim();

            const tel = (
              c.REP_TEL ??
              c.TELEFONO ??
              c.CELULAR ??
              c.TEL ??
              ''
            ).toString().trim();

            // Estatus base que viene del JSON
            const estBase = (c.ESTATUS ?? c.estatus ?? '').toString();
            // Estatus guardado en memoria/localStorage
            const key  = diaDKey(secKey, casId);
            const sav  = diaDEstado[key] || {};
            const estFinal = normalizarEstatusDiaD(sav.estatus || estBase);

            out.push({
              seccion: secKey,
              casilla: casId,
              domicilio: dom,
              rep,
              tel,
              estatus: estFinal
            });
          }
        }
        return out;
      }

      // ==== Ventana de captura de actas D√≠a D ====

      let diaDActaPrevView = null; // para recordar zoom del universo

      function initDiaDActaUI(){
        const btn   = document.getElementById('diaD-acta-btn');
        const modal = document.getElementById('diaD-acta-modal');
        const hdr   = modal ? modal.querySelector('.hdr') : null;
        const btnClose = document.getElementById('diaD-acta-close');
        const btnMin   = document.getElementById('diaD-acta-min');
        const btnCancel= document.getElementById('diaD-acta-cancel');
        const btnSave  = document.getElementById('diaD-acta-save');
        const inpSec   = document.getElementById('diaD-acta-sec');
        const selCas   = document.getElementById('diaD-acta-casilla');
        const gridPart = document.getElementById('diaD-acta-partidos-grid');

        if (!btn || !modal || !inpSec || !selCas || !gridPart) return;

        // Construir inputs de partidos
        gridPart.innerHTML = DIA_D_PARTIDOS.map(p => `
          <div>
            <label style="display:block; font-size:11px; color:#4b5563;">
              ${p.label}
            </label>
            <input type="number" min="0" value="0"
                  data-partido="${p.key}"
                  style="width:100%;"/>
          </div>
        `).join('');

        function abrirModal(){
          modal.style.display = 'block';
          // guardamos vista previa para regresar al universo
          const map = ensureLeafletMap();
          diaDActaPrevView = { center: map.getCenter(), zoom: map.getZoom() };
          inpSec.focus();
        }

        function cerrarModal(){
          modal.style.display = 'none';
        }

        btn.addEventListener('click', abrirModal);
        btnClose.addEventListener('click', cerrarModal);
        btnCancel.addEventListener('click', cerrarModal);
        btnMin.addEventListener('click', () => {
          modal.style.display = 'none';   // por ahora s√≥lo esconder
        });

        // Drag del modal desde la cabecera
        if (hdr) {
          let dragging = false;
          let startX = 0, startY = 0, origLeft = 0, origTop = 0;

          hdr.style.cursor = 'move';

          hdr.addEventListener('mousedown', (e) => {
            dragging = true;
            startX = e.clientX;
            startY = e.clientY;
            const rect = modal.getBoundingClientRect();
            origLeft = rect.left;
            origTop = rect.top;
            document.body.style.userSelect = 'none';
          });

          window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            let nextLeft = origLeft + dx;
            let nextTop  = origTop + dy;
            // Mantener dentro de la ventana
            const maxLeft = window.innerWidth - modal.offsetWidth - 8;
            const maxTop  = window.innerHeight - modal.offsetHeight - 8;
            nextLeft = Math.max(8, Math.min(nextLeft, maxLeft));
            nextTop  = Math.max(8, Math.min(nextTop, maxTop));

            modal.style.left = `${nextLeft}px`;
            modal.style.top = `${nextTop}px`;
            modal.style.right = 'auto';
            modal.style.bottom = 'auto';
            modal.style.transform = 'none';
          });

          window.addEventListener('mouseup', () => {
            if (!dragging) return;
            dragging = false;
            document.body.style.userSelect = '';
          });
        }

        // Cuando se captura la secci√≥n ‚Üí zoom + llenar select de casillas
        inpSec.addEventListener('change', async () => {
          const sec = inpSec.value.trim();
          if (!sec) return;

          // 1) Zoom al pol√≠gono de secci√≥n
          const feats = (window.AT_DATA?.features || []);
          const feat = feats.find(f => String(f.properties?.SECCION) === sec);
          const map  = ensureLeafletMap();
          if (feat){
            const tmp = L.geoJSON(feat);
            try {
              map.fitBounds(tmp.getBounds(), { padding: [20,20] });
            } catch(_) {}
            tmp.remove();
          }

          // 2) Casillas disponibles seg√∫n DIA_D_BY_SEC
          await ensureDiaDDataLoaded();
          const casillas = DIA_D_BY_SEC.get(sec) || [];
          if (!casillas.length){
            selCas.innerHTML = '<option value="">‚Äî Secci√≥n sin casillas D√≠a D ‚Äî</option>';
            return;
          }

          selCas.innerHTML = '<option value="">‚Äî Selecciona casilla ‚Äî</option>' +
            casillas.map(c => {
              const id = (c.CASILLA_ID ?? c.CASILLA ?? c.CLAVE ?? '').toString();
              const t  = (c.TIPO ?? '').toString();
              const label = [id, t].filter(Boolean).join(' ¬∑ ');
              return `<option value="${id}">${label}</option>`;
            }).join('');

          // Si ya hay acta para la primera casilla, luego podr√≠amos precargarla
        });

        // Guardar acta
        btnSave.addEventListener('click', () => {
          const sec = inpSec.value.trim();
          const cas = selCas.value.trim();
          const puesto = (document.getElementById('dd-acta-puesto')?.value || 'A').toUpperCase();

          // Ejemplo: lees otros campos que ya tienes
          const folio  = document.getElementById('dd-acta-folio')?.value || '';
          const hora   = document.getElementById('dd-acta-hora')?.value || '';
          const notas  = document.getElementById('dd-acta-notas')?.value || '';

          if (!sec || !cas){
            alert('Falta el tipo de eleccion, la secci√≥n o la casilla en el contexto del acta.');
            return;
          }




          const nulos = Number(document.getElementById('diaD-acta-nulos').value || 0);
          const total = Number(document.getElementById('diaD-acta-total').value || 0);
          const inci  = document.getElementById('diaD-acta-incidencia').value.trim();

          const votos = {};
          gridPart.querySelectorAll('input[data-partido]').forEach(inp => {
            const key = inp.getAttribute('data-partido');
            votos[key] = Number(inp.value || 0);
          });

          if (!DIA_D_ACTAS[sec]) DIA_D_ACTAS[sec] = {};
          DIA_D_ACTAS[sec][cas] = {
            partido: votos,
            totalVotos: total,
            nulos,
            incidencia: inci,
            ts: new Date().toISOString()
          };

          guardarDiaDActas();
          console.log('[D√≠a D] Acta guardada', sec, cas, DIA_D_ACTAS[sec][cas]);

          // TODO: aqu√≠ recalculamos ganador y repintamos mapa
          actualizarPintaPorActas(sec);

          // regresar al universo
          const map = ensureLeafletMap();
          if (diaDActaPrevView){
            map.setView(diaDActaPrevView.center, diaDActaPrevView.zoom);
          }

          updateDiaDPanelForSection(sec, cas, puesto);


        });
      }

      // stub para la l√≥gica de color (la llenamos en el siguiente paso)
      function actualizarPintaPorActas(sec){
        console.log('[D√≠a D] actualizarPintaPorActas pendiente para secci√≥n', sec);
      }


      // Ya tienes otros DOMContentLoaded, puedes agregar este sin problema
      document.addEventListener('DOMContentLoaded', () => {
        initDiaDToolbar();
        initDiaDActaUI(); // activa bot√≥n y modal de captura de actas
      });

      // Bot√≥n para mostrar el mapa y la capa de casillas bajo demanda
      document.addEventListener('DOMContentLoaded', () => {
        const btnShowMap = document.getElementById('btn-show-casillas');
        if (btnShowMap){
          btnShowMap.addEventListener('click', mostrarMapaCasillas);
        }
      });

      function actualizarKPIsDiaD(){
        // Usamos los marcadores ya cargados; si no existen, caemos al total de estado guardado
        const total = (typeof DIA_D_MARKERS?.size === 'number' && DIA_D_MARKERS.size > 0)
          ? DIA_D_MARKERS.size
          : Object.keys(diaDEstado).length;

        let instaladas = 0;
        let incidencia = 0;
        let actas = 0;
        let cerradas = 0;
        let sinrep  = 0;

        for (const key in diaDEstado){
          const st = diaDEstado[key]?.estatus || "sin_rep";

          switch(st){
            case "instalada": instaladas++; break;
            case "incidencia": incidencia++; break;
            case "acta_recibida": actas++; break;
            case "cerrada": cerradas++; break;
            case "sin_rep": sinrep++; break;
          }
        }

        const avance = total > 0 ? ((actas / total) * 100).toFixed(1) : 0;

        document.getElementById("kpi-total").textContent = total;
        document.getElementById("kpi-instaladas").textContent = instaladas;
        document.getElementById("kpi-incidencia").textContent = incidencia;
        document.getElementById("kpi-actas-rec").textContent = actas;
        document.getElementById("kpi-cerradas").textContent = cerradas;
        document.getElementById("kpi-sinrep").textContent = sinrep;
        document.getElementById("kpi-avance").textContent = avance + "%";
      }


    </script>

    <!-- ===== Barra de filtros D√≠a D (estatus global) ===== -->
      <div id="diaD-status-toolbar">
        <button type="button" class="diaD-filter-btn" data-diaD-estatus="sin_rep" data-est="sin_rep">‚ùå Sin rep</button>
        <button type="button" class="diaD-filter-btn" data-diaD-estatus="instalada" data-est="instalada">üü° Instaladas</button>
        <button type="button" class="diaD-filter-btn" data-diaD-estatus="incidencia" data-est="incidencia">‚ö†Ô∏è Incidencias</button>
        <button type="button" class="diaD-filter-btn" data-diaD-estatus="acta_recibida" data-est="acta_recibida">üü¢ Acta recibida</button>
        <button type="button" class="diaD-filter-btn" data-diaD-estatus="cerrada" data-est="cerrada">‚¨õ Cerradas</button>
      </div>

      <!-- ===== Panel global de casillas filtradas por estatus ===== -->
      <div id="diaD-filter-panel" class="diaD-filter-hidden">
        <div id="diaD-filter-titlebar">üìã Filtro D√≠a D</div>
        <div class="hdr">
          <div class="ttl">
            <div class="ttl-main" id="diaD-filter-title">Casillas por estatus</div>
            <div class="ttl-sub" id="diaD-filter-sub">‚Äî</div>
          </div>
          <button id="diaD-filter-close" class="btn-close" aria-label="Cerrar">√ó</button>
        </div>
        <div class="body">
          <table id="diaD-filter-table">
            <thead>
              <tr>
                <th>Secci√≥n</th>
                <th>Casilla</th>
                <th>Domicilio</th>
                <th>Representante / Tel.</th>
                <th>Estatus</th>
              </tr>
            </thead>
            <tbody id="diaD-filter-tbody">
              <!-- Se llena desde JS -->
            </tbody>
          </table>
        </div>
      </div>


    <!-- ===== Men√∫ D√≠a D: Cambiar estatus ===== -->
    <div id="diaD-menu-estatus" class="diaD-menu hidden">
      <div data-est="sin_rep">‚ùå Sin representante</div>
      <div data-est="instalada">üü° Casilla instalada</div>
      <div data-est="incidencia">‚ö†Ô∏è Incidencia</div>
      <div data-est="acta_recibida">üü¢ Acta recibida</div>
      <div data-est="cerrada">‚¨õ Casilla cerrada</div>
    </div>

    <!-- ===== Dashboard global D√≠a D ===== -->

    <div id="diaD-dashboard">
      <div class="dd-wrap">
        <div class="dd-title">Dashboard D√≠a "D"</div>
        <div class="dd-cards">
          <div class="dd-card dd-total">
            <span class="dd-label">Casillas</span>
            <span class="dd-val" id="dd-total">‚Äî</span>
          </div>
          <div class="dd-card dd-sinrep">
            <span class="dd-label">Sin rep</span>
            <span class="dd-val" id="dd-sinrep">‚Äî</span>
          </div>
          <div class="dd-card dd-instalada">
            <span class="dd-label">Instaladas</span>
            <span class="dd-val" id="dd-instalada">‚Äî</span>
          </div>
          <div class="dd-card dd-incidencia">
            <span class="dd-label">Incidencias</span>
            <span class="dd-val" id="dd-incidencia">‚Äî</span>
          </div>
          <div class="dd-card dd-acta">
            <span class="dd-label">Acta recibida</span>
            <span class="dd-val" id="dd-acta">‚Äî</span>
          </div>
          <div class="dd-card dd-cerrada">
            <span class="dd-label">Cerradas</span>
            <span class="dd-val" id="dd-cerrada">‚Äî</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Bot√≥n flotante para abrir captura de acta -->
    <div id="diaD-acta-btn">
      <span class="icon">üìÑ</span> CAPTURAR ACTA
    </div>

    <!-- Ventana de captura de actas D√≠a D -->
    <div id="diaD-acta-modal">
      <div class="hdr">
        <div class="hdr-title">Captura de acta ¬∑ D√≠a "D"</div>
        <div class="hdr-actions">
          <button type="button" id="diaD-acta-min" title="Minimizar">‚Äî</button>
          <button type="button" id="diaD-acta-close" title="Cerrar">√ó</button>
        </div>
      </div>
      <div class="body">
        <!-- Paso 1: secci√≥n / casilla -->

        <!-- Selector de tipo de elecci√≥n del acta -->
      <div class="dd-field-group">
        <label for="dd-acta-puesto" class="dd-label">
          Tipo de elecci√≥n del acta
        </label>
        <select id="dd-acta-puesto" class="dd-input">
          <option value="A">Ayuntamiento (A)</option>
          <option value="DL">Diputado Local (DL)</option>
          <option value="DF">Diputado Federal (DF)</option>
          <option value="S">Senador (S)</option>
          <option value="G">Gobernador (G)</option>
          <option value="P">Presidente (P)</option>
        </select>
      </div>


        <div class="form-row">
          <div style="flex:0 0 120px;">
            <label>Secci√≥n</label>
            <input type="text" id="diaD-acta-sec" placeholder="ej. 1234" />
          </div>
          <div style="flex:1;">
            <label>Casilla</label>
            <select id="diaD-acta-casilla">
              <option value="">‚Äî Selecciona despu√©s de la secci√≥n ‚Äî</option>
            </select>
          </div>
        </div>

        <div class="body actas-diaD-body">

        <!-- Paso 2: votos por partido -->
        <div>
          <label>Votos por partido</label>
          <div class="partidos-grid" id="diaD-acta-partidos-grid">
            <!-- Se genera desde JS -->
          </div>
        </div>

        <!-- Totales / incidencias -->
        <div class="form-row">
          <div style="flex:0 0 120px;">
            <label>Votos nulos</label>
            <input type="number" id="diaD-acta-nulos" min="0" value="0" />
          </div>
          <div style="flex:0 0 120px;">
            <label>Total acta</label>
            <input type="number" id="diaD-acta-total" min="0" value="0" />
          </div>
          <div style="flex:1;">
            <label>Incidencias (opcional)</label>
            <input type="text" id="diaD-acta-incidencia"
                  placeholder="Breve descripci√≥n" />
          </div>
        </div>

        <div class="footer">
          <button type="button" id="diaD-acta-cancel">Cancelar</button>
          <button type="button" id="diaD-acta-save">Guardar acta</button>
        </div>
      </div>
    </div>

  </body>
</html>
